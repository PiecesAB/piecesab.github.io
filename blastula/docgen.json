{"date": "3/21/2024 10:37:34 PM", "namespaces": {"Blastula": {"classes": {"Blastodisc": {"kind": "class", "bases": ["Node2D", "IVariableContainer"], "inners": {"DeleteAction": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "BulletsRemain", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ClearMyBullets", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ClearAllBullets", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "enabled", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mainSchedule", "static": "false", "kind": "field", "mainType": "BaseSchedule", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletsExecutable", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "cleanupSchedule", "static": "false", "kind": "field", "mainType": "BaseSchedule", "defaultValue": "", "comment": {"summary": " This schedule runs when the Blastodisc is about to be deleted. Be careful if the schedule is a child, because it could be deleted, and waiting would not work. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deleteAction", "static": "false", "kind": "field", "mainType": "DeleteAction", "defaultValue": "DeleteAction.BulletsRemain", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "speedMultiplier", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "1f", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customData", "static": "false", "kind": "property", "mainType": "Dictionary&lt;string, Variant&gt;", "defaultValue": "new Dictionary&lt;string, Variant&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "all", "static": "true", "kind": "field", "mainType": "HashSet&lt;Blastodisc&gt;", "defaultValue": "new HashSet&lt;Blastodisc&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "primordial", "static": "true", "kind": "field", "mainType": "Blastodisc", "defaultValue": "null", "comment": {"summary": " This must be the first blastodisc that exists, and is within the kernel. It exists so that when a blastodisc is deleted, there is still a way to handle its bullets. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "new HashSet&lt;string&gt;()\r\n        {\r\n            \"t\", \"shot_count\"\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "Shoot", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"operation": {"paramType": "BaseOperation", "defaultValue": ""}}}, {"id": "Inherit", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " Makes the BNode a child of the Blastodisc's master structure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "ClearBullets", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Deletes all bullets associated with this Blastodisc. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"deletionEffect": {"paramType": "bool", "defaultValue": "true"}}}, {"id": "ClearBulletsForAll", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ExecuteAll", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Fires bullet structures! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "MoreMath": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "RDMod", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Performs a % n where a / n is rounded down. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "int", "defaultValue": ""}, "n": {"paramType": "int", "defaultValue": ""}}}, {"id": "RDMod", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": " Performs a % n where a / n is rounded down. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "float", "defaultValue": ""}, "n": {"paramType": "float", "defaultValue": ""}}}, {"id": "Log", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": " Performs a logarithm with base b. Godot has DegToRad but not this? ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"x": {"paramType": "float", "defaultValue": ""}, "b": {"paramType": "float", "defaultValue": ""}}}, {"id": "GCD", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Greatest common denominator. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "int", "defaultValue": ""}, "b": {"paramType": "int", "defaultValue": ""}}}, {"id": "LCM", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Least common multiple. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "int", "defaultValue": ""}, "b": {"paramType": "int", "defaultValue": ""}}}, {"id": "FastInvNorm", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": " Returns an approximate inverse normal function; two-tailed. How many standard deviations away from the mean would the left and right sides need to be to contain (x * 100)% of the area? ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"x": {"paramType": "float", "defaultValue": ""}}}, {"id": "MoveTowardsAngle", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"current": {"paramType": "float", "defaultValue": ""}, "goal": {"paramType": "float", "defaultValue": ""}, "maxDelta": {"paramType": "float", "defaultValue": ""}}}, {"id": "Slerp", "static": "true", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"from": {"paramType": "Transform2D", "defaultValue": ""}, "to": {"paramType": "Transform2D", "defaultValue": ""}, "t": {"paramType": "float", "defaultValue": ""}}}, {"id": "Lerp", "static": "true", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"from": {"paramType": "Transform2D", "defaultValue": ""}, "to": {"paramType": "Transform2D", "defaultValue": ""}, "t": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "RNG": {"kind": "class", "bases": [], "inners": {"FloatInt": {"kind": "struct", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DoubleLong": {"kind": "struct", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "Reseed", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"seed": {"paramType": "uint", "defaultValue": ""}}}, {"id": "Int", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"min": {"paramType": "int", "defaultValue": ""}, "max": {"paramType": "int", "defaultValue": ""}}}, {"id": "Sign", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Single", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"min": {"paramType": "float", "defaultValue": "0f"}, "max": {"paramType": "float", "defaultValue": "1f"}}}, {"id": "Double", "static": "true", "kind": "method", "mainType": "double", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"min": {"paramType": "double", "defaultValue": "0f"}, "max": {"paramType": "double", "defaultValue": "1f"}}}, {"id": "UnitCircle", "static": "true", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"surfaceOnly": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "UnitSphere", "static": "true", "kind": "method", "mainType": "Vector3", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"surfaceOnly": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "NormalDist", "static": "true", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"mean": {"paramType": "float", "defaultValue": ""}, "sd": {"paramType": "float", "defaultValue": ""}, "min": {"paramType": "float", "defaultValue": "float.NegativeInfinity"}, "max": {"paramType": "float", "defaultValue": "float.PositiveInfinity"}}}, {"id": "Color", "static": "true", "kind": "method", "mainType": "Color", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"opacitySet": {"paramType": "float", "defaultValue": "1"}}}], "comment": {"summary": " We obviously don't want true randomness in patterns and collectibles for a bullet game - that would ruin replays! But we also don't want the same game every time. Be sure to reseed and save the seed value at the beginning of every stage! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UtilityFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "PathBuilder", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " This is used to convert a node hierarchy into string IDs.<br /> It performs Act function with the node and its new ID, where registering can be handled.<br /><br /> NodeA                   ID: NodeA<br /> - NodeR                 ID: NodeA/NodeR<br /> - NodeS                 ID: NodeA/NodeS<br /> --- NodeX               ID: NodeA/NodeS/NodeX<br /> --- NodeY               ID: NodeA/NodeS/NodeY<br /> - NodeT                 ID: NodeA/NodeT<br /> --- NodeZ               ID: NodeA/NodeT/NodeZ<br /> - # Holder<br /> --- NodeU               ID: NodeA/NodeU<br /><br /> If we ignoreRoot, all these IDs would have \"NodeA/\" omitted, and NodeA itself wouldn't be registered. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"root": {"paramType": "Node", "defaultValue": ""}, "Act": {"paramType": "Action<Node, string>", "defaultValue": ""}, "ignoreRoot": {"paramType": "bool", "defaultValue": "false"}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ExpressionSolver": {"kind": "class", "bases": [], "inners": {"VarInfo": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "expr", "static": "false", "kind": "field", "mainType": "Expression", "defaultValue": "new Expression()", "comment": {"summary": " For stored parsing and execution. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "parseSuccess", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "vars", "static": "false", "kind": "field", "mainType": "List&lt;string&gt;", "defaultValue": "new List&lt;string&gt;()", "comment": {"summary": " The variables in the expression, which we need to solve. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "constantResult", "static": "false", "kind": "field", "mainType": "Variant", "defaultValue": "default", "comment": {"summary": " If the result is constant, store it here. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "NodeInfo": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "exprs", "static": "false", "kind": "field", "mainType": "Dictionary&lt;string, VarInfo&gt;", "defaultValue": "new Dictionary&lt;string, VarInfo&gt;()", "comment": {"summary": " Key is the name of the variable in Godot. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SolveStatus": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Unsolved", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SolvedNormal", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SolvedConstant", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "currentLocalContainer", "static": "true", "kind": "field", "mainType": "IVariableContainer", "defaultValue": "", "comment": {"summary": " This is the current blastodisc, if it exists. Used to resolve local variables. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "nodeToVars", "static": "true", "kind": "field", "mainType": "Dictionary&lt;ulong, NodeInfo&gt;", "defaultValue": "new Dictionary&lt;ulong, NodeInfo&gt;()", "comment": {"summary": " Turns instance IDs of Nodes (not BNodes) into their information. That way we're ready to solve them when the formula is executed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PopulateNames", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"vars": {"paramType": "List<string>", "defaultValue": ""}, "s": {"paramType": "string", "defaultValue": ""}}}, {"id": "ResolveVariable", "static": "true", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "ResolveVariables", "static": "true", "kind": "method", "mainType": "Godot.Collections.Array", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"vars": {"paramType": "List<string>", "defaultValue": ""}}}, {"id": "Solve", "static": "true", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"node": {"paramType": "Node", "defaultValue": ""}, "varName": {"paramType": "string", "defaultValue": ""}, "varValue": {"paramType": "string", "defaultValue": ""}, "solveStatus": {"paramType": "SolveStatus", "defaultValue": ""}, "errorValue": {"paramType": "Variant", "defaultValue": "default"}}}, {"id": "Unsolve", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"node": {"paramType": "Node", "defaultValue": ""}, "varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "ClearNode", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"node": {"paramType": "Node", "defaultValue": ""}}}], "comment": {"summary": " Godot already has a powerful expression parser! What luck. But we still need to define some variables. This class manages variables in order to use expressions in bullet operations. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Waiters": {"kind": "class", "bases": [], "inners": {"BoxedBool": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "b", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "sceneLoadCounter", "static": "true", "kind": "property", "mainType": "long", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IncrementSceneLoadCounter", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "WaitOneFrame", "static": "true", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dispatcher": {"paramType": "Node", "defaultValue": ""}, "ignorePause": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "WaitFrames", "static": "true", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dispatcher": {"paramType": "Node", "defaultValue": ""}, "frames": {"paramType": "int", "defaultValue": ""}, "ignorePause": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "WaitSeconds", "static": "true", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dispatcher": {"paramType": "Node", "defaultValue": ""}, "seconds": {"paramType": "float", "defaultValue": ""}, "ignorePause": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "WaitUntil", "static": "true", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dispatcher": {"paramType": "Node", "defaultValue": ""}, "Condition": {"paramType": "Func<bool>", "defaultValue": ""}}}, {"id": "DelayedQueueFree", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"toDelete": {"paramType": "Node", "defaultValue": ""}, "waitTime": {"paramType": "float", "defaultValue": ""}, "units": {"paramType": "Wait.TimeUnits", "defaultValue": ""}}}, {"id": "WaitUntilBoxedBool", "static": "true", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dispatcher": {"paramType": "Node", "defaultValue": ""}, "b": {"paramType": "BoxedBool", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "FrameCounter": {"kind": "class", "bases": ["Node"], "inners": {"Buffer": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "startFrame", "static": "false", "kind": "property", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "length", "static": "false", "kind": "property", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Elapsed", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "FramesRemaining", "static": "false", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "BecameElapsedThisFrame", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "WillBecomeElapsedNextFrame", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Replenish", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Restarts the buffer to this frame. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Replenish", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Restarts the buffer to this frame, and sets the number of frames until it elapses. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newLength": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "Deplete", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Immediately makes the buffer elapsed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetLength", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newLength": {"paramType": "ulong", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Cache&lt;T&gt;": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "data", "static": "false", "kind": "property", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsValid", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Invalidate", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Update", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newData": {"paramType": "T", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DictCache&lt;K, V&gt;": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "IsValid", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"key": {"paramType": "K", "defaultValue": ""}}}, {"id": "Update", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"key": {"paramType": "K", "defaultValue": ""}, "newData": {"paramType": "V", "defaultValue": ""}}}, {"id": "Get", "static": "false", "kind": "method", "mainType": "V", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"key": {"paramType": "K", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "realGameFrame", "static": "true", "kind": "property", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Number of real frames since the program began, regardless of pausing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "stageFrame", "static": "true", "kind": "property", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Number of unpaused frames since the stage began. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "realSessionFrame", "static": "true", "kind": "property", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Number of frames since the session began, regardless of pausing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ResetStageFrame", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ResetSessionFrame", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Elapsed", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"startFrame": {"paramType": "ulong", "defaultValue": ""}, "frameCount": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "GetStageTime", "static": "true", "kind": "method", "mainType": "double", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BNode": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "initialized", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "worldTransformMode", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": " If true, transform is the world transform (for optimization purposes), otherwise the local transform. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "transform", "static": "false", "kind": "field", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "children", "static": "false", "kind": "field", "mainType": "UnsafeArray&lt;int&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "behaviors", "static": "false", "kind": "field", "mainType": "UnsafeArray&lt;BehaviorOrder&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletRenderID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " ID for bullet rendering. No graphic nor collision if renderID &lt; 0. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "laserRenderID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " ID for laser rendering. For any bullet that makes up the laser. No graphic nor collision if renderID &lt; 0. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "treeSize", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " treeSize = 1 + (treeSize of all children).<br /> We aren't lazy to set it. It should always be accurate. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "treeDepth", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " treeDepth = 0 with no children, otherwise 1 + max(treeDepth of all children). We are lazy here: removing children won't decrease the depth even though it should sometimes. To be sure, please recalculate it. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "parentIndex", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " Index of the parent. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "positionInParent", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " Position within the parent's child list. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionLayer", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " Internal ID used for determining this bullet's collision role. For example enemy shot, player shot, collectible, etc. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionSleepStatus", "static": "false", "kind": "field", "mainType": "SleepStatus", "defaultValue": "", "comment": {"summary": " Whether this bullet is sleeping / can sleep. Used to optimize collision. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "graze", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": " How this variable is handled is largely up to player(s). It's used for the current time (in frames) the player(s) grazed this bullet. It can be set to a negative number for enemy bullets to disable grazing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "power", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": " How this variable is handled is largely up to colliding objects. It's used for player shots to actually deal an amount of damage. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "health", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": " How this variable is handled is largely up to colliding objects. It is used for handling piercing player shots, and making enemy bullets undeletable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "multimeshExtras", "static": "false", "kind": "field", "mainType": "BNodeMultimeshExtras*", "defaultValue": "", "comment": {"summary": " This is where color or custom data are defined when needed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " A BNode can be a bullet, or a bullet acting as a container for other bullets. ", "examples": [], "remarks": " In the documentation, the collection of a root BNode with its child bullets is sometimes called a \"structure\". ", "returns": "", "params": {}, "typeParams": {}}}, "BNodeMultimeshExtras": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "color", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "custom", "static": "false", "kind": "field", "mainType": "Vector4", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BNodeFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "masterQueue", "static": "true", "kind": "field", "mainType": "BNode*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mqHead", "static": "true", "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": " This should always be the earliest uninitialized BNode in the master queue. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mqTail", "static": "true", "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": " This should always be the earliest initialized BNode in the master queue, or the head for an empty queue. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mqSize", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "262144", "comment": {"summary": " If mqSize is a power of 2, modulus is a bitmask; counting on the compiler to help. <br /> Also, we can only store one less than this, lest mqHead == mqTail when full. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "multithreadCutoff", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "256", "comment": {"summary": " If the bullet's tree is larger than this, we use multithreading for certain operations. ", "examples": [], "remarks": " We don't always multithread because Parallel.For has scheduling overhead. ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "starterBNode", "static": "true", "kind": "field", "mainType": "BNode*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MasterQueueCount", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MasterQueueRemainingCapacity", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MasterQueuePopOne", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Allocates the next available BNode, if possible. ", "examples": [], "remarks": "", "returns": "The index to that BNode in masterQueue", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MasterQueuePopN", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Allocates n available BNodes, if possible. ", "examples": [], "remarks": "", "returns": "The index to the first such BNode in masterQueue.", "params": {}, "typeParams": {}}, "methodParams": {"n": {"paramType": "int", "defaultValue": ""}}}, {"id": "MasterQueuePushOne", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}}}, {"id": "MasterQueuePushTree", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}}}, {"id": "InitializeQueue", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "CloneOne", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}}}, {"id": "CloneN", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "n": {"paramType": "int", "defaultValue": ""}}}, {"id": "SetTransform2D", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "transform": {"paramType": "Transform2D", "defaultValue": ""}}}, {"id": "SetColliderInfo", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "bulletLayer": {"paramType": "int", "defaultValue": ""}, "canSleep": {"paramType": "bool", "defaultValue": ""}}}, {"id": "Rotate", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "radians": {"paramType": "float", "defaultValue": ""}}}, {"id": "MakeSpaceForChildren", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "howMany": {"paramType": "int", "defaultValue": ""}}}, {"id": "RecalculateTreeDepth", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Recalculates this BNode's depth and all of its parents' depths too.<br /> We're lazy and only recalculate when necessary! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}}}, {"id": "SetChild", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "The possible index of the old child (in case you want to destroy it)", "params": {"i": "BNode index in masterQueue.", "ci": "Position to modify within the children list", "ti": "BNode index of target new child in masterQueue"}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "ci": {"paramType": "int", "defaultValue": ""}, "ti": {"paramType": "int", "defaultValue": ""}}}, {"id": "DeleteAllChildren", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}}}, {"id": "AddBehavior", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "order": {"paramType": "BehaviorOrder", "defaultValue": ""}}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Performs all behaviors of masterQueue[i] recursively. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ExecuteManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "debugTimer", "static": "true", "kind": "field", "mainType": "Stopwatch", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PostExecuteManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "debugTimer", "static": "true", "kind": "field", "mainType": "Stopwatch", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PostExecute": {"kind": "class", "bases": [], "inners": {"DeleteOrder": {"kind": "struct", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "OperationOrder": {"kind": "struct", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " No need to delete pointers, this class exists for the whole game, whether you like it or not. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ScheduleDeletion", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " This will delete the BNode the next time PerformScheduled runs. Because this is called from Execute, we make sure multithreading doesn't fray our list. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}, "useDeletionEffect": {"paramType": "bool", "defaultValue": ""}}}, {"id": "ScheduleOperation", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}, "opID": {"paramType": "long", "defaultValue": ""}}}, {"id": "PerformScheduled", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Only run on the main thread. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " There exist operations we want to do on the main thread after Execute. This class handles the scheduling and performing of such operations. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Boundary": {"kind": "class", "bases": ["Node2D"], "inners": {"Form": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Rectangle", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Circle", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LowLevelInfo": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "form", "static": "false", "kind": "field", "mainType": "Form", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "center", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "size", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "extent", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ReflectData": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "globalPosition", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotation", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "ID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "form", "static": "false", "kind": "field", "mainType": "Form", "defaultValue": "Form.Rectangle", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "defaultSize", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "new Vector2(500, 500)", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "inheritSize", "static": "false", "kind": "field", "mainType": "Control", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "updates", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "moveToGlobalPosition", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "colorInEditor", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "Colors.White", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "boundaryFromID", "static": "true", "kind": "field", "mainType": "Dictionary&lt;string, Boundary&gt;", "defaultValue": "new Dictionary&lt;string, Boundary&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lowLevelInfo", "static": "false", "kind": "field", "mainType": "LowLevelInfo*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsWithin", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"boundInfo": {"paramType": "LowLevelInfo*", "defaultValue": ""}, "globalPos": {"paramType": "Vector2", "defaultValue": ""}, "shrink": {"paramType": "float", "defaultValue": ""}}}, {"id": "Clamp", "static": "true", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"boundInfo": {"paramType": "LowLevelInfo*", "defaultValue": ""}, "globalPos": {"paramType": "Vector2", "defaultValue": ""}, "shrink": {"paramType": "float", "defaultValue": ""}}}, {"id": "Wrap", "static": "true", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"boundInfo": {"paramType": "LowLevelInfo*", "defaultValue": ""}, "globalPos": {"paramType": "Vector2", "defaultValue": ""}, "shrink": {"paramType": "float", "defaultValue": ""}}}, {"id": "Reflect", "static": "true", "kind": "method", "mainType": "ReflectData", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"boundInfo": {"paramType": "LowLevelInfo*", "defaultValue": ""}, "rdIn": {"paramType": "ReflectData", "defaultValue": ""}, "shrink": {"paramType": "float", "defaultValue": ""}, "reflectPerpendicular": {"paramType": "bool", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "MainBoundary": {"kind": "class", "bases": ["Boundary"], "inners": {"MainType": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Single", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The single screen of a one-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Left", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The left screen of a two-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Right", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The right screen of a two-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Count", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Not a boundary name. Used to be the number of main boundary types. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "MainType", "defaultValue": "MainType.Single", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "boundPerMode", "static": "true", "kind": "field", "mainType": "MainBoundary[]", "defaultValue": "new MainBoundary[(int)MainType.Count]", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mainLowLevelInfos", "static": "true", "kind": "field", "mainType": "Boundary.LowLevelInfo**", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsOnScreen", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " Returns true if this point is on any screen (a.k.a. MainBoundary). Used to check if a bullet is on screen (negative shrink value to account for the bullet graphic). ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"globalPos": {"paramType": "Vector2", "defaultValue": ""}, "shrink": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": " A boundary for the game's main screen(s). ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Target": {"kind": "class", "bases": ["Node2D"], "inners": {}, "declarations": [{"id": "ID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Target\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetNumberFromID", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetTargetCount", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetTargetCount", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"IDNumber": {"paramType": "int", "defaultValue": ""}}}, {"id": "GetClosest", "static": "true", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "string", "defaultValue": ""}, "pos": {"paramType": "Vector2", "defaultValue": ""}}}, {"id": "GetClosest", "static": "true", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"IDNumber": {"paramType": "int", "defaultValue": ""}, "pos": {"paramType": "Vector2", "defaultValue": ""}}}, {"id": "GetPointerToTransform", "static": "false", "kind": "method", "mainType": "Transform2D*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "GrazeLines": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "maxLineCount", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "32", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ShowLine", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"start": {"paramType": "Vector2", "defaultValue": ""}, "end": {"paramType": "Vector2", "defaultValue": ""}}}], "comment": {"summary": " \t/// A sort of bonus effect class; draws a line between the player and bullet when graze occurs. \t/// ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Player": {"kind": "class", "bases": ["Node2D"], "inners": {"Control": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "SinglePlayer", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The only player in a one-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "LeftPlayer", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The left player in a two-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RightPlayer", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The right player in a two-player game. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "control", "static": "false", "kind": "field", "mainType": "Control", "defaultValue": "Control.SinglePlayer", "comment": {"summary": " Determines the player's role. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "normalSpeed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "500", "comment": {"summary": " Player's normal speed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "focusedSpeed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "200", "comment": {"summary": " Player's speed during the focus input. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "boundaryShrink", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "30", "comment": {"summary": " Unit count which shrinks the boundary that constrains the player to the screen. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "hurtbox", "static": "false", "kind": "field", "mainType": "BlastulaCollider", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "grazebox", "static": "false", "kind": "field", "mainType": "BlastulaCollider", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "framesBetweenLaserGraze", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "8", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugInvincible", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "varDiscs", "static": "false", "kind": "field", "mainType": "List&lt;Blastodisc&gt;", "defaultValue": "new List&lt;Blastodisc&gt;()", "comment": {"summary": " Blastodiscs in this list will recieve important variables such as \"shoot\" and \"focus\". These variables are important to make player shots function correctly. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "playersByControl", "static": "true", "kind": "field", "mainType": "System.Collections.Generic.Dictionary&lt;Control, Player&gt;", "defaultValue": "new System.Collections.Generic.Dictionary&lt;Control, Player&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnHit", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"collider": {"paramType": "BlastulaCollider", "defaultValue": ""}, "bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "IsShooting", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsFocused", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetMovementDirection", "static": "false", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"normalized": {"paramType": "bool", "defaultValue": "false"}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "EnemyMover": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "easingTransition", "static": "false", "kind": "field", "mainType": "Tween.TransitionType", "defaultValue": "Tween.TransitionType.Quad", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "easingType", "static": "false", "kind": "field", "mainType": "Tween.EaseType", "defaultValue": "Tween.EaseType.InOut", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "startVelocity", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "Vector2.Zero", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tweenDuration", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "0.5f", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radialVelocityInterpolation", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "enemy", "static": "false", "kind": "field", "mainType": "Enemy", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RadialToCartesian", "static": "true", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"v": {"paramType": "Vector2", "defaultValue": ""}}}, {"id": "CartesianToRadial", "static": "true", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"v": {"paramType": "Vector2", "defaultValue": ""}}}, {"id": "GetVelocity", "static": "false", "kind": "method", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetTargetVelocity", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newVelocity": {"paramType": "Vector2", "defaultValue": ""}}}, {"id": "SetTargetPosition", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newPosition": {"paramType": "Vector2", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Spawner": {"kind": "class", "bases": ["Node2D", "IVariableContainer"], "inners": {}, "declarations": [{"id": "spawnSchedule", "static": "false", "kind": "field", "mainType": "BaseSchedule", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "enemySamples", "static": "false", "kind": "field", "mainType": "PackedScene[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "repeatMode", "static": "false", "kind": "field", "mainType": "Repaint.PatternMode", "defaultValue": "Repaint.PatternMode.Loop", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "spawnID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": " The spawnID starts at this number. A \"spawn_id\" variable is set in enemies to be the count at the time it was created (starting with this one -- by default the first enemy spawn has spawn_id == 0) ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "selfLifespan", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "5", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "selfLifespanUnits", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Seconds", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customData", "static": "false", "kind": "property", "mainType": "Dictionary&lt;string, Variant&gt;", "defaultValue": "new Dictionary&lt;string, Variant&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "new HashSet&lt;string&gt;()\r\n        {\r\n             \"pos\", \"spawn_id\", \"spawn_count\"\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "Spawn", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Spawn enemies using... you guessed it... a schedule. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "EnemyFormation": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "enemyCount", "static": "false", "kind": "property", "mainType": "int", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "spawnerCount", "static": "false", "kind": "property", "mainType": "int", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "myStageSector", "static": "false", "kind": "field", "mainType": "StageSector", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "CheckEmpty", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IncrementEnemy", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DecrementEnemy", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IncrementSpawner", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DecrementSpawner", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " This is meant to be attached to the root of a scene which as loaded for a StageSector. It can keep track of enemies and spawners, so that the sector ends when the last enemy is defeated. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Enemy": {"kind": "class", "bases": ["Node2D", "IVariableContainer"], "inners": {"DefenseMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Absorb", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Only the damage left over after subtracting the defense is counted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Scale", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The damage is multiplied by (1 - defense). ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "health", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "100", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lowHealthCutoff", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "-1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "defenseMode", "static": "false", "kind": "field", "mainType": "DefenseMode", "defaultValue": "DefenseMode.Scale", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "defense", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "movementSchedule", "static": "false", "kind": "field", "mainType": "BaseSchedule", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deletionParticlePool", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"ExplodeMedium\"", "comment": {"summary": " A child of the enemy which is activated and placed into the parent when destroyed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "selfMinLifespan", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "-1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "selfMaxLifespan", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "-1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lifespanUnits", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lifeLeft", "static": "false", "kind": "property", "mainType": "float", "defaultValue": "float.PositiveInfinity", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "maxHealth", "static": "false", "kind": "property", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "defeated", "static": "false", "kind": "property", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "onScreen", "static": "false", "kind": "property", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customData", "static": "false", "kind": "property", "mainType": "System.Collections.Generic.Dictionary&lt;string, Variant&gt;", "defaultValue": "new System.Collections.Generic.Dictionary&lt;string, Variant&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "new HashSet&lt;string&gt;()\r\n        {\r\n            \"pos\", \"dpos\", \"enemy_count\", \"health_frac\", \"on_screen\"\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "OnHit", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"collider": {"paramType": "BlastulaCollider", "defaultValue": ""}, "bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "BecomeDefeated", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "BecameVisibleFromNotifier", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NoLongerVisibleFromNotifier", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "AddOrGetEnemyMover", "static": "false", "kind": "method", "mainType": "EnemyMover", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " This contains variables for the purpose of movement scheduling. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DefaultPauseMenu": {"kind": "class", "bases": ["Control"], "inners": {"State": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Unpaused", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Pausing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Paused", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Unpausing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "state", "static": "false", "kind": "field", "mainType": "State", "defaultValue": "State.Unpaused", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PAUSE_OPEN_CLOSE_DELAY", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "5", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "UnpausingAnimation", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PausingAnimation", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SectorTimer": {"kind": "class", "bases": ["Control"], "inners": {}, "declarations": [{"id": "integerPart", "static": "false", "kind": "field", "mainType": "Label", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "fractionalPart", "static": "false", "kind": "field", "mainType": "Label", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mainViewHolder", "static": "false", "kind": "field", "mainType": "Control", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "StageSectorChanged", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newSector": {"paramType": "StageSector", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StageManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "StageSectorChangedEventHandler", "static": "false", "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newSector": {"paramType": "StageSector", "defaultValue": ""}}}, {"id": "StageChangedEventHandler", "static": "false", "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newStage": {"paramType": "StageSector", "defaultValue": ""}}}, {"id": "main", "static": "true", "kind": "property", "mainType": "StageManager", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Collision": {"classes": {"CollisionManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "objectLayersHolder", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletLayersHolder", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletLayerIDFromName", "static": "true", "kind": "field", "mainType": "Dictionary&lt;string, int&gt;", "defaultValue": "new Dictionary&lt;string, int&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "objectLayerIDFromName", "static": "true", "kind": "field", "mainType": "Dictionary&lt;string, int&gt;", "defaultValue": "new Dictionary&lt;string, int&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "objectsDetectedByBulletLayers", "static": "true", "kind": "field", "mainType": "List&lt;List&lt;int&gt;&gt;", "defaultValue": "new List&lt;List&lt;int&gt;&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletLayerCount", "static": "true", "kind": "field", "mainType": "int", "defaultValue": "1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "objectLayerCount", "static": "true", "kind": "field", "mainType": "int", "defaultValue": "1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugTimer", "static": "true", "kind": "field", "mainType": "Stopwatch", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetObjectLayerIDFromName", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetBulletLayerIDFromName", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Shape": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "None", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Circle", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " collisionSize.X determines the radius of the collider. collisionSize.Y doesn't matter! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Collision": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "bNodeIndex", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ObjectColliderInfo": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "transform", "static": "false", "kind": "field", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shape", "static": "false", "kind": "field", "mainType": "Shape", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "size", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionListPtr", "static": "false", "kind": "field", "mainType": "IntPtr", "defaultValue": "", "comment": {"summary": " Leads to a Blastula.LowLevel.LinkedList&lt;CollisionData&gt;. Represents the bullets that collided with this object this frame; processed appropriately. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "colliderID", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BulletColliderInfo": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "shape", "static": "false", "kind": "field", "mainType": "Shape", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "size", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SleepStatus": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "canSleep", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "isSleeping", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CollisionSolver": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RegisterObject", "static": "true", "kind": "method", "mainType": "IntPtr", "defaultValue": "", "comment": {"summary": " Register an object for bullets to collide with. IntPtr returned is a LinkedList&lt;IntPtr&gt;.Node for future deletion. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"objectInfoPtr": {"paramType": "IntPtr", "defaultValue": ""}, "objectLayer": {"paramType": "int", "defaultValue": ""}}}, {"id": "UnregisterObject", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"deletionPtr": {"paramType": "IntPtr", "defaultValue": ""}, "objectLayer": {"paramType": "int", "defaultValue": ""}}}, {"id": "ExecuteCollisionAll", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Execute this after all behaviors so there is no inconsistency with movement. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BlastulaCollider": {"kind": "class", "bases": ["Node2D"], "inners": {"ShowMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Never", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Editor", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Always", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "shape", "static": "false", "kind": "field", "mainType": "Shape", "defaultValue": "Shape.Circle", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "size", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "new Vector2(12, 0)", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "objectLayer", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"None\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "showMode", "static": "false", "kind": "field", "mainType": "ShowMode", "defaultValue": "ShowMode.Editor", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "CollisionEventHandler", "static": "false", "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "colliderInfo", "static": "false", "kind": "field", "mainType": "ObjectColliderInfo*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisions", "static": "false", "kind": "field", "mainType": "LinkedList&lt;Collision&gt;*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deletionPtr", "static": "false", "kind": "field", "mainType": "IntPtr", "defaultValue": "IntPtr.Zero", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ID", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "-1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Graphics": {"classes": {"BulletGraphicPreview": {"kind": "class", "bases": ["Node2D"], "inners": {}, "declarations": [{"id": "graphicsContainer", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "graphicName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Default\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "useMaterial", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "countInCircle", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "12", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circleRadiusMultiplier", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionColor", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "new Color(0, 0, 0, 0)", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "render", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BulletRendererManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "bulletGraphicsRoot", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "selectorSample", "static": "false", "kind": "field", "mainType": "MultimeshBullet", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "multiMeshSample", "static": "false", "kind": "field", "mainType": "MultiMesh", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "field", "mainType": "BulletRendererManager", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugTimer", "static": "true", "kind": "field", "mainType": "Stopwatch", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "STAGE_TIME_ROLLOVER", "static": "true", "kind": "const", "mainType": "double", "defaultValue": "60.0 * 60.0 * 3.0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "STAGE_TIME_NAME", "static": "true", "kind": "field", "mainType": "string", "defaultValue": "\"STAGE_TIME\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetGraphicInfoFromID", "static": "true", "kind": "method", "mainType": "GraphicInfo", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"id": {"paramType": "int", "defaultValue": ""}}}, {"id": "GetIDFromName", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetNameFromID", "static": "true", "kind": "method", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " Drives the rendering of bullets. For lasers, see LaserRendererNode. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "GraphicInfo": {"kind": "class", "bases": ["Node"], "inners": {"ExtraMultimeshFields": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Color", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "CustomData", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "2", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "texture", "static": "false", "kind": "field", "mainType": "Texture2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "modulate", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "Colors.White", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "size", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "Vector2.One * 8", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "material", "static": "false", "kind": "field", "mainType": "ShaderMaterial", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "unrotatedGraphic", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "zIndex", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "autoRainbow", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionShape", "static": "false", "kind": "field", "mainType": "Collision.Shape", "defaultValue": "Collision.Shape.Circle", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionSize", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "new Vector2(12, 0)", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "extraMultimeshFields", "static": "false", "kind": "field", "mainType": "ExtraMultimeshFields", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MakeMultimeshBullet", "static": "false", "kind": "method", "mainType": "MultimeshBullet", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"selectorSample": {"paramType": "MultimeshBullet", "defaultValue": ""}, "multiMeshSample": {"paramType": "MultiMesh", "defaultValue": ""}, "newName": {"paramType": "string", "defaultValue": ""}}}, {"id": "MakeLaserMeshInstance", "static": "false", "kind": "method", "mainType": "MeshInstance2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"meshInstanceSample": {"paramType": "MeshInstance2D", "defaultValue": ""}, "arrayMeshSample": {"paramType": "ArrayMesh", "defaultValue": ""}, "newName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LaserRendererManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "laserGraphicsRoot", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "meshInstanceSample", "static": "false", "kind": "field", "mainType": "MeshInstance2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "arrayMeshSample", "static": "false", "kind": "field", "mainType": "ArrayMesh", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "field", "mainType": "LaserRendererManager", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugTimer", "static": "true", "kind": "field", "mainType": "Stopwatch", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetGraphicInfoFromID", "static": "true", "kind": "method", "mainType": "GraphicInfo", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"id": {"paramType": "int", "defaultValue": ""}}}, {"id": "GetIDFromName", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetNameFromID", "static": "true", "kind": "method", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " Drives the rendering of lasers. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LaserRenderer": {"kind": "class", "bases": [], "inners": {"LaserDataEntry": {"kind": "struct", "bases": [], "inners": {"Purpose": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Mid", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Head", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Tail", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "2", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Singleton", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "3", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "bNodeIndex", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "purpose", "static": "false", "kind": "field", "mainType": "Purpose", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lastGrazedFrame", "static": "false", "kind": "field", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "laserDataEntries", "static": "true", "kind": "field", "mainType": "CircularQueue&lt;LaserDataEntry&gt;*", "defaultValue": "null", "comment": {"summary": " Outer index: laser render ID. Stores lasers contiguously in the queue. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "nonzeroRenderIDs", "static": "true", "kind": "field", "mainType": "HashSet&lt;int&gt;", "defaultValue": "new HashSet&lt;int&gt;()", "comment": {"summary": " Tracks the render IDs which currently exist in at least one bullet. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "renderedVertices", "static": "true", "kind": "field", "mainType": "Vector2[][]", "defaultValue": "null", "comment": {"summary": " outer index = the laser render ID. each vertex list is one triangle strip. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "renderedUVs", "static": "true", "kind": "field", "mainType": "Vector2[][]", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "queuePositions", "static": "true", "kind": "field", "mainType": "int*", "defaultValue": "", "comment": {"summary": " Stores positions in the render queue, for later deletion. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "laserRenderWidthFromRenderIDs", "static": "true", "kind": "field", "mainType": "float*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "laserRenderStretchFromRenderIDs", "static": "true", "kind": "field", "mainType": "float*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "colliderInfoFromRenderIDs", "static": "true", "kind": "field", "mainType": "Collision.BulletColliderInfo*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsBNodeHeadOfLaser", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "IsBNodePartOfLaser", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "IsBNodeTailOfLaser", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "GetHeadBNodeOfLaser", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "NewGrazeThisFrame", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " Determines if a new graze is possible for a laser in this frame. If so, return true, and no more grazes will be possible this frame. Otherwise return false. We need this because multiple bullets in a laser can be grazed in the same frame. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}, "headBNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "RemoveLaserEntry", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "SetLaserFromHead", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"headBNodeIndex": {"paramType": "int", "defaultValue": ""}, "newRenderID": {"paramType": "int", "defaultValue": ""}}}, {"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"idCount": {"paramType": "int", "defaultValue": ""}}}, {"id": "RenderAll", "static": "true", "kind": "method", "mainType": "List&lt;int&gt;", "defaultValue": "", "comment": {"summary": " Returns the list of structures that have been removed due to being empty. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Used by the Renderer class. We only draw lasers here. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ScreenSetup": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "objectViewports", "static": "false", "kind": "field", "mainType": "SubViewport[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ParticleEffectPool": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "ID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "sample", "static": "false", "kind": "field", "mainType": "PackedScene", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "count", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "50", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PlayEffect", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "string", "defaultValue": ""}, "position": {"paramType": "Vector2", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BulletRenderer": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "bNodesFromRenderIDs", "static": "true", "kind": "field", "mainType": "CircularQueue&lt;int&gt;*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "nonzeroRenderIDs", "static": "true", "kind": "field", "mainType": "HashSet&lt;int&gt;", "defaultValue": "new HashSet&lt;int&gt;()", "comment": {"summary": " Tracks the render IDs which currently exist in at least one bullet. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "renderedTransformArrays", "static": "true", "kind": "field", "mainType": "float[][]", "defaultValue": "null", "comment": {"summary": " Outer index: render ID. <br /> Each inner array should resize to avoid the Multimesh bottleneck. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "queuePositions", "static": "true", "kind": "field", "mainType": "int*", "defaultValue": "", "comment": {"summary": " Stores positions in the render queue, for later deletion. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DELETION_COLOR_SHADER_PARAM", "static": "true", "kind": "field", "mainType": "string", "defaultValue": "\"tint\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deletionColorFromRenderIDs", "static": "true", "kind": "field", "mainType": "Color*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "meshSizeFromRenderIDs", "static": "true", "kind": "field", "mainType": "Vector2*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "colliderInfoFromRenderIDs", "static": "true", "kind": "field", "mainType": "Collision.BulletColliderInfo*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "unrotatedGraphicFromRenderIDs", "static": "true", "kind": "field", "mainType": "bool*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "extraMultimeshFieldsFromRenderIDs", "static": "true", "kind": "field", "mainType": "GraphicInfo.ExtraMultimeshFields*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "strideFromRenderIDs", "static": "true", "kind": "field", "mainType": "int*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"idCount": {"paramType": "int", "defaultValue": ""}}}, {"id": "SetRenderID", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}, "newRenderID": {"paramType": "int", "defaultValue": ""}}}, {"id": "IsBulletOnScreen", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " May give false positives. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "DELETION_EFFECT_FRAMES", "static": "true", "kind": "const", "mainType": "float", "defaultValue": "40", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DELETION_EFFECT_RECT_SIZE", "static": "true", "kind": "const", "mainType": "float", "defaultValue": "40", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ConvertToDeletionEffects", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "RenderAll", "static": "true", "kind": "method", "mainType": "List&lt;int&gt;", "defaultValue": "", "comment": {"summary": " Returns the list of structures that have been removed due to being empty. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "RainbowInfo": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "shaderParamaterName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"tint\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "colors", "static": "false", "kind": "field", "mainType": "Color[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "names", "static": "false", "kind": "field", "mainType": "string[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Holds the data to a type of rainbow, for use in applying them to bullet appearances. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "MultimeshBullet": {"kind": "class", "bases": ["MultiMeshInstance2D"], "inners": {}, "declarations": [{"id": "GetBufferCount", "static": "false", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetBuffer", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"buf": {"paramType": "float[]", "defaultValue": ""}, "visibleLength": {"paramType": "int", "defaultValue": ""}, "stride": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "FPSDisplay": {"kind": "class", "bases": ["Label"], "inners": {}, "declarations": [{"id": "currFPS", "static": "true", "kind": "field", "mainType": "float", "defaultValue": "60", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "field", "mainType": "FPSDisplay", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DefaultLogoController": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "mainLogo", "static": "false", "kind": "field", "mainType": "Control", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugNotification", "static": "false", "kind": "field", "mainType": "Control", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.LowLevel": {"classes": {"BulletWorldTransforms": {"kind": "class", "bases": [], "inners": {"TransformScratchSpace": {"kind": "struct", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Get", "static": "true", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": " Get the world transform of a bullet. \"Threadsafe\" because it only reads and populates, nothing changes. Also, it's important that version number is set in this order. At worst we do extra work by writing the same thing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}, {"id": "Set", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Helper to set the local transform that results in the desired world transform. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}, "newWorldTransform": {"paramType": "Transform2D", "defaultValue": ""}}}, {"id": "Invalidate", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " This forces us to recalculate the world position. Important for lasers to not look extremely stupid. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"bNodeIndex": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " This class updates the world position of all BNodes as they appear in the masterQueue. We require world position for rendering and collision checking. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UnsafeCurve": {"kind": "struct", "bases": [], "inners": {"LoopMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Neither", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Right", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Left", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Both", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "samples", "static": "false", "kind": "field", "mainType": "UnsafeArray&lt;float&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "initialized", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "startTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "loopMode", "static": "false", "kind": "field", "mainType": "LoopMode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Evaluate", "static": "false", "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"time": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": " Represents an unmanaged baked curve. Evaluated by linear interpolation. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UnsafeCurveFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "Create", "static": "true", "kind": "method", "mainType": "UnsafeCurve*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"realCurve": {"paramType": "Curve", "defaultValue": ""}, "startTime": {"paramType": "float", "defaultValue": ""}, "endTime": {"paramType": "float", "defaultValue": ""}, "loopMode": {"paramType": "UnsafeCurve.LoopMode", "defaultValue": ""}, "stepFrames": {"paramType": "float", "defaultValue": ""}}}, {"id": "Dispose", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"curve": {"paramType": "UnsafeCurve", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CircularQueue&lt;T&gt;": {"kind": "struct", "bases": [], "inners": {"TInit": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "item", "static": "false", "kind": "field", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "initialized", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "data", "static": "false", "kind": "field", "mainType": "TInit*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "head", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " The head is the next uninitialized item to claim. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tail", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " The tail is the earliest initialized item. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "capacity", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Stores a list of VALUES (it copies them.) ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {"T": ""}}}, "CircularQueueFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "Create", "static": "true", "kind": "method", "mainType": "CircularQueue&lt;T&gt;", "defaultValue": "", "comment": {"summary": " Warning: we can only store one less than capacity. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"capacity": {"paramType": "int", "defaultValue": ""}}}, {"id": "Count", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}}}, {"id": "SpaceFree", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}}}, {"id": "Add", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Returns the index where the space was made, for future tracking. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}, "item": {"paramType": "T", "defaultValue": ""}}}, {"id": "Remove", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}, "index": {"paramType": "int", "defaultValue": ""}}}, {"id": "AdvanceTail", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Ensures the tail is the earliest initialized item. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}}}, {"id": "RetractHead", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Ensures the head is the next uninitialized item to claim. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}}}, {"id": "GetList", "static": "true", "kind": "method", "mainType": "CircularQueue&lt;T&gt;.TInit", "defaultValue": "", "comment": {"summary": " Gets the item as if this queue were a list, including holes. tail is index 0. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}, "index": {"paramType": "int", "defaultValue": ""}}}, {"id": "Dispose", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"queue": {"paramType": "CircularQueue<T>", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LinkedList&lt;T&gt;": {"kind": "struct", "bases": [], "inners": {"Node": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "prev", "static": "false", "kind": "field", "mainType": "Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "next", "static": "false", "kind": "field", "mainType": "Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "data", "static": "false", "kind": "field", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "head", "static": "false", "kind": "field", "mainType": "Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tail", "static": "false", "kind": "field", "mainType": "Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "count", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Standard-issue doubly linked list. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {"T": ""}}}, "LinkedListFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "Create", "static": "true", "kind": "method", "mainType": "LinkedList&lt;T&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "AddHead", "static": "true", "kind": "method", "mainType": "LinkedList&lt;T&gt;.Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}, "v": {"paramType": "T", "defaultValue": ""}}}, {"id": "AddTail", "static": "true", "kind": "method", "mainType": "LinkedList&lt;T&gt;.Node*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}, "v": {"paramType": "T", "defaultValue": ""}}}, {"id": "GetHead", "static": "true", "kind": "method", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}}}, {"id": "GetTail", "static": "true", "kind": "method", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}}}, {"id": "RemoveHead", "static": "true", "kind": "method", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}}}, {"id": "RemoveTail", "static": "true", "kind": "method", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}}}, {"id": "RemoveByNode", "static": "true", "kind": "method", "mainType": "T", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}, "n": {"paramType": "LinkedList<T>.Node*", "defaultValue": ""}}}, {"id": "Dispose", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"l": {"paramType": "LinkedList<T>", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BehaviorReceipt": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "throttle", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "delete", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "useDeletionEffect", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "noMultithreading", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " This return information affects future behaviors after the one just executed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BehaviorOrder": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "data", "static": "false", "kind": "field", "mainType": "void*", "defaultValue": "", "comment": {"summary": " Data specific to the BNode. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "dataSize", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": " Size of data (bytes). Used for cloning purposes. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Orders a behavior to occur; stores data needed to execute it. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BehaviorOrderFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "empty", "static": "true", "kind": "field", "mainType": "BehaviorOrder", "defaultValue": "new BehaviorOrder() { func = null, data = null, dataSize = 0 }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Clone", "static": "true", "kind": "method", "mainType": "BehaviorOrder", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"b": {"paramType": "BehaviorOrder*", "defaultValue": ""}}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "b": {"paramType": "BehaviorOrder*", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}}}, {"id": "Dispose", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"b": {"paramType": "BehaviorOrder*", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UnsafeArray&lt;T&gt;": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "array", "static": "false", "kind": "field", "mainType": "T*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "count", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Stores a list of VALUES (it copies them.) ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {"T": " Unmanaged type of the array. "}}}, "UnsafeArrayFunctions": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "Create", "static": "true", "kind": "method", "mainType": "UnsafeArray&lt;T&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"count": {"paramType": "int", "defaultValue": ""}}}, {"id": "Create", "static": "true", "kind": "method", "mainType": "UnsafeArray&lt;T&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"arr": {"paramType": "List<T>", "defaultValue": ""}}}, {"id": "Clone", "static": "true", "kind": "method", "mainType": "UnsafeArray&lt;T&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<T>", "defaultValue": ""}}}, {"id": "CloneBehaviorOrder", "static": "true", "kind": "method", "mainType": "UnsafeArray&lt;BehaviorOrder&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<BehaviorOrder>", "defaultValue": ""}}}, {"id": "Set", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<T>", "defaultValue": ""}, "index": {"paramType": "int", "defaultValue": ""}, "newValue": {"paramType": "T", "defaultValue": ""}}}, {"id": "Expand", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<T>", "defaultValue": ""}, "howMany": {"paramType": "int", "defaultValue": ""}, "filler": {"paramType": "T", "defaultValue": "default"}}}, {"id": "Dispose", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<T>", "defaultValue": ""}}}, {"id": "DisposeBehaviorOrder", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"a": {"paramType": "UnsafeArray<BehaviorOrder>", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Operations": {"classes": {"Spin": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "RotateAfter", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Apply rotation after the current transform, which has the effect of rotating this item in place. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RotateBefore", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Apply rotation before the current transform, which has the effect of rotating relative to the parent. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "speed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.RotateAfter", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "speed", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"60\"", "comment": {"summary": " Degrees per second. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " Also known as angular velocity! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Adapt": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "useCondition", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "conditionValue", "static": "false", "kind": "field", "mainType": "bool*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "conditionOpID", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "wait", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "scheduledOpID", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "queued", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "operation", "static": "false", "kind": "field", "mainType": "BaseOperation", "defaultValue": "", "comment": {"summary": " The operation that applies to this BNode after the wait time elapses or the condition becomes true, whichever is earlier. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "condition", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "wait", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"120\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "waitUnits", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "blastodisc", "static": "false", "kind": "field", "mainType": "Blastodisc", "defaultValue": "", "comment": {"summary": " Optional blastodisc from which to use local variables. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "conditionValue", "static": "false", "kind": "field", "mainType": "bool*", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " After a number of frames, the structure rooted at this node will be deleted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StunMultithreading": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "duration", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "elapsed", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "duration", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"120\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "units", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " After a number of frames, the structure rooted at this node will be deleted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ActOnBoundary": {"kind": "class", "bases": ["AddBehavior"], "inners": {"SpecialAction": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "None", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Wrap", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Reflect", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "boundInfo", "static": "false", "kind": "field", "mainType": "Boundary.LowLevelInfo*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialAction", "static": "false", "kind": "field", "mainType": "SpecialAction", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "hitsRemaining", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "opID", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shrink", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "reflectPerpendicular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "specialAction", "static": "false", "kind": "field", "mainType": "SpecialAction", "defaultValue": "SpecialAction.Reflect", "comment": {"summary": " Choose a special boundary-specific interaction. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "boundaryID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": " The boundary's name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "operation", "static": "false", "kind": "field", "mainType": "BaseOperation", "defaultValue": "", "comment": {"summary": " Delayed operation to perform as soon as the final hit occurs. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "hits", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": " The number of hits to execute with this boundary. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shrink", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "0", "comment": {"summary": " The amount by which the boundary is shrunk.  Useful to make bullets appear to bounce at the edges instead of the center. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "reflectPerpendicular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, reflection will make the target structure rotate perpendicularly to the wall, instead of in the natural direction. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " After a number of frames, the structure rooted at this node will be deleted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TimeStretch": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "curve", "static": "false", "kind": "field", "mainType": "UnsafeCurve*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "curveSourceOperation", "static": "false", "kind": "field", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "reciprocated", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "curveShift", "static": "false", "kind": "field", "mainType": "Vector4", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "curve", "static": "false", "kind": "field", "mainType": "Curve", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "startTime", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endTime", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"60\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "units", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "loopMode", "static": "false", "kind": "field", "mainType": "UnsafeCurve.LoopMode", "defaultValue": "UnsafeCurve.LoopMode.Neither", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "curveShift", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "reciprocated", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "stepFrames", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "3f", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "BakeCurveIfNeeded", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " This alters the speed of time itself... over time. It's weird but it may be useful. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Forth": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "MoveAfter", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Apply movement after the current transform, relative to this object's own space. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MoveBefore", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Apply movement before the current transform, relative to the parent. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "speed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "useWorldSpaceHack", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.MoveAfter", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "speed", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"100\"", "comment": {"summary": " Forward movement speed in Godot units per second. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "worldSpaceHack", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " Puts the BNode in world space instead of local space, which avoids matrix multiplications. Useful if you want to squeeze out ridiculous performance, but the BNode will now ignore its parent. So this hack works for only simple movement. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}, {"id": "Add", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}, "speed": {"paramType": "float", "defaultValue": ""}, "mode": {"paramType": "Mode", "defaultValue": ""}}}], "comment": {"summary": " Move forward. The simplest behavior for all bullets. Ubiquitious in all bullet games! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Lifespan": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "duration", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deletionEffect", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "duration", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"600\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "units", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "deletionEffect", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}, {"id": "Add", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}, "duration": {"paramType": "float", "defaultValue": ""}, "units": {"paramType": "Wait.TimeUnits", "defaultValue": ""}, "deletionEffect": {"paramType": "bool", "defaultValue": "false"}}}], "comment": {"summary": " After some duration, the bullet structure will be deleted. Just as organisms must die in reality, to avoid depleting the ecosystem's resources, So must bullet structures die to make room in the master queue. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Aim": {"kind": "class", "bases": ["AddBehavior"], "inners": {"AimMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Instant", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The first time this behavior executes, instantly aim towards the target. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Homing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " This continuously tries to change the angle to arrive at the target. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TargetType": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "TargetNode", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " \"target\" is the name of a Target node. It will try to aim towards the closest one. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "LocalPosition", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " \"target\" is an expression for a Vector2. It aims toward that point with the reference frame of this structure's parent. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GlobalPosition", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " \"target\" is an expression for a Vector2. It aims towards that point in world space. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "aimMode", "static": "false", "kind": "field", "mainType": "AimMode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetPosition", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetPositionIsLocal", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angularOffsetRadians", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "aimComplete", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "parentLevel", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "homingSpeed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "homingWindow", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentFrame", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "aimMode", "static": "false", "kind": "field", "mainType": "AimMode", "defaultValue": "AimMode.Instant", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetType", "static": "false", "kind": "field", "mainType": "TargetType", "defaultValue": "TargetType.TargetNode", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Player\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angularOffset", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": " Degrees offset, to aim around the target instead of directly toward it. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "parentLevel", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "1", "comment": {"summary": " How many parents up must we go to solve a local position? ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "homingSpeed", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"120\"", "comment": {"summary": " Degrees per second to rotate towards a target. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "homingWindow", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Vector2(0, 60)\"", "comment": {"summary": " If defined, it's a Vector2 with (X, Y) being the (start frame count, end frame count) of homing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " Aim towards a Target or fixed position. Sometimes we want bullets to actually try and hit something!!! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Morph": {"kind": "class", "bases": ["AddBehavior"], "inners": {"State": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Unstarted", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Playing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Complete", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "throttle", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "throttleOnEndFrame", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "state", "static": "false", "kind": "field", "mainType": "State", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "duration", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentTime", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tempRenderID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "origRenderID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "appearancePersists", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "scaleMultiplier", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "origScale", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "interpolateColor", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "origColor", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetColor", "static": "false", "kind": "field", "mainType": "Color", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "interpolateCustom", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "origCustom", "static": "false", "kind": "field", "mainType": "Vector4", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetCustom", "static": "false", "kind": "field", "mainType": "Vector4", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "appearance", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Mist\"", "comment": {"summary": " The ID of the appearance during this time. Leave it empty to not change the appearance. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "appearancePersists", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, the appearance will remain after emergence is complete. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "duration", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"12\"", "comment": {"summary": " Duration of the wait. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "durationUnits", "static": "false", "kind": "field", "mainType": "Wait.TimeUnits", "defaultValue": "Wait.TimeUnits.Frames", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "scaleMultiplier", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "3f", "comment": {"summary": " Multiplies the scale by this much at the animation's beginning. Shrinks to original size throughout the emergence. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "throttle", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "0.8f", "comment": {"summary": " How much this throttles the following behaviors. 0 = behavior proceeds as normal. 1 = behavior stops. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "multimeshColor", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " We expect a Color here. Interpolates to this over the duration of the behavior.  ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "multimeshCustom", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " We expect a Vector4 here. Interpolates to this over the duration of the behavior.  ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "throttleOnEndFrame", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " Whether this throttles on the last frame before it ends. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " This can be used to delay the existence and function of a bullet, or add the animation of the bullet appearing to fade into existence. It can also interpolate color and custom data for Multimeshes. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Follow": {"kind": "class", "bases": ["AddBehavior"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Attach", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Sets the transform to the target's transform directly. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Linear", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Move exactly at the maxSpeed every frame, or onto the target if close enough to get there in one frame. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Elastic", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Accelerates to the target. This will overshoot it, creating an orbit or oscillation. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specificTarget", "static": "false", "kind": "field", "mainType": "Transform2D*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetID", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "maxSpeed", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "accel", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotateStructure", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "followingWindow", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "approachRadius", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentFrame", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentVelocity", "static": "false", "kind": "field", "mainType": "Vector2", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.Linear", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specificTarget", "static": "false", "kind": "field", "mainType": "Target", "defaultValue": "", "comment": {"summary": " If defined, follow this particular target (useful for bullets to follow multiple enemies at once.) ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": " If specificTarget is not defined, the closest target with the given targetName is calculated every frame. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "maxSpeed", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"300\"", "comment": {"summary": " The fastest we can move to follow something, in units per second. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotateStructure", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, the BNode is rotated in the direction of its calculated follow movement. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "followingWindow", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " If defined, it's a Vector2 with (X, Y) being the (start frame count, end frame count) of following. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "approachRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": " The distance that the bullet will begin to slow down in its approach. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "accel", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"300\"", "comment": {"summary": " With elastic movement, how quickly we can change the speed? In units per second^2. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "initialVelocity", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"Vector2(0, 0)\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}], "comment": {"summary": " Causes a bullet structure to follow a Target. Can follow smoothly! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CreateSingle": {"kind": "class", "bases": ["Creator"], "inners": {}, "declarations": [{"id": "renderName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"None\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionLayerName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"EnemyShot\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "sleepyCollision", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BaseOperation": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "ProcessStructure", "static": "false", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Processes a bullet tree rooted at a certain BNode. ", "examples": [], "remarks": "", "returns": "Index of the output BNode in the master queue.", "params": {"inStructure": "Index of the input BNode in the master queue"}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}}}, {"id": "operationFromID", "static": "true", "kind": "field", "mainType": "Dictionary&lt;long, BaseOperation&gt;", "defaultValue": "new Dictionary&lt;long, BaseOperation&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OperationIDExists", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ID": {"paramType": "long", "defaultValue": ""}}}, {"id": "GetOperationID", "static": "false", "kind": "method", "mainType": "long", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Solve", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "Unsolve", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Force recalculation of the expression at varName; for example, when it's changed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " Base class for all Blastula \"operations\". These normally work together to create a bullet structure in a Sequence, but some can act independently in any schedule context. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Modifier": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "ModifyStructure", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " An operation that only modifies the bullet structure in place. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "AddBehavior": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [{"id": "CreateOrder", "static": "false", "kind": "method", "mainType": "BehaviorOrder", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " A type of operation that adds behavior to a BNode. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Cascade": {"kind": "class", "bases": ["Modifier"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "All", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Run on every node in the tree. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Depth", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Run on every node with a particular depth. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DistanceFromRoot", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Run on every node with a particular distance from the root. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "subOperation", "static": "false", "kind": "field", "mainType": "Modifier", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.Depth", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "targetValue", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "recalculateDepths", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Operates on all nodes at a certain depth level within a BNode's structure. Only ModifyOperation is allowed. Depth is the maximum distance to a BNode with no children. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Comment": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [], "comment": {"summary": " This operation does absolutely nothing. Insert it into a schedule or operation sequence when you want to change the node's name to explain something. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Creator": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "CreateStructure", "static": "false", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Produces a bullet structure from nothing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Discrete": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [{"id": "Run", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " An operation that does absolutely nothing to any bullet structure. Mainly used in certain self-contained operations, such as setting a variable or playing a sound. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ForEachChild": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "progressVariable", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"t\"", "comment": {"summary": " Interpolates from 0 to 1 as the operation progresses. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true,  ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "countVariable", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " This variable counts the bullets starting at zero. 0, 1, 2, 3... ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Applies an operation on all children, while linearly interpolating several numeric properties. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Macro": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [], "comment": {"summary": " Opaque wrapper around a series of operations. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Reference": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "sequenceID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "other", "static": "false", "kind": "field", "mainType": "BaseOperation", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Perform another operation indirectly. Can be used to interchange pipeline pieces during the game! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Sequence": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "execute", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"true\"", "comment": {"summary": " Execute the sequence if this is true. Otherwise does nothing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "referenceID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " Optional ID. If nonempty, this sequence can be referenced throughout all scenes, as long as it exists. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "referencesByID", "static": "true", "kind": "field", "mainType": "Dictionary&lt;string, Sequence&gt;", "defaultValue": "new Dictionary&lt;string, Sequence&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ProcessStructureLikeSequence", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"holder": {"paramType": "Node", "defaultValue": ""}, "inStructure": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " Applies (in tree order) all direct child operations of a node. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Shaper": {"kind": "class", "bases": ["BaseOperation"], "inners": {"ShapingMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Clone", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Restructures clones of this structure into the shape as children of a new node. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Place", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Alters the transforms of children in this bullet structure. Works best when \"number\" equals child count. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SelfAtZeroth", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Alters the transform of this object as if it were the 0th element of its parent. Useful particularly for random shots. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TransformOrder": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "ApplyBefore", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ApplyAfter", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "RotationMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "None", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Don't rotate the children at all. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Root", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Rotates the children of the new structure, but un-rotates the grandchildren. As such, grandchildren seem to remain unrotated, though their holder has been rotated. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Full", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Rotates the whole structure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "number", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"12\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shapingMode", "static": "false", "kind": "field", "mainType": "ShapingMode", "defaultValue": "ShapingMode.Clone", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotationMode", "static": "false", "kind": "field", "mainType": "RotationMode", "defaultValue": "RotationMode.Full", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "transformOrder", "static": "false", "kind": "field", "mainType": "TransformOrder", "defaultValue": "TransformOrder.ApplyBefore", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetElementTransform", "static": "false", "kind": "method", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": " i is the child index - imagine 0 to be the first and (number - 1) to be the last. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"i": {"paramType": "int", "defaultValue": ""}, "totalCount": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " A Shaper will add a defined shape to bullets. The way it adds shape is customizable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Polygon": {"kind": "class", "bases": ["Macro"], "inners": {}, "declarations": [{"id": "sides", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"5\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"100\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletsPerSide", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"10\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Macro that places a polygon.<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StarPolygon": {"kind": "class", "bases": ["Macro"], "inners": {}, "declarations": [{"id": "sides", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "5", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "leapSize", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "2", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"100\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "bulletsPerSide", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"18\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "makeGCDCopies", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, this makes a deeper container with copies of the lower-sided stars, if the leapSize and sides share a common factor. This will make a star look complete even in that case -- for example the Star of David is two triangles; it can be produced with sides = 6 and leapSize = 2 and makeGCDCopies = true. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Macro that places a star polygon.<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ClearBehaviors": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [], "comment": {"summary": " Deletes the behavior list of this BNode. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ForthByPosition": {"kind": "class", "bases": ["Modifier"], "inners": {"RotationMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "DoNothing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Set", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Add", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "forthMode", "static": "false", "kind": "field", "mainType": "Forth.Mode", "defaultValue": "Forth.Mode.MoveAfter", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotationMode", "static": "false", "kind": "field", "mainType": "RotationMode", "defaultValue": "RotationMode.Set", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "positionMultiplier", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": " How much to retain the original positions? ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Takes the local position within each child, and converts it to a Forth behavior where distance becomes speed. A simple way to add velocity in a certain shape, and apply positioning afterward. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "InnerShift": {"kind": "class", "bases": ["Modifier"], "inners": {"RotationMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "None", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "FromOtherRotation", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "FromOtherPosition", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "auxiliary", "static": "false", "kind": "field", "mainType": "BaseOperation", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "transformMode", "static": "false", "kind": "field", "mainType": "Shift.Mode", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotationMode", "static": "false", "kind": "field", "mainType": "RotationMode", "defaultValue": "RotationMode.FromOtherRotation", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "placement", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "movementSpeed", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " We create an auxiliary structure homologous to this one, apply its position information to the main structure, and then delete the auxiliary structure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Repaint": {"kind": "class", "bases": ["Modifier"], "inners": {"ReplaceMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Self", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Set the graphic of this parent of the structure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Direct", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Directly sets the graphic of the children. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DeepReplace", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Looks deeply into each child for all bullets within that are rendered, and replaces those graphics. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PatternMode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Clamp", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Loop", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Random", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "replaceMode", "static": "false", "kind": "field", "mainType": "ReplaceMode", "defaultValue": "ReplaceMode.DeepReplace", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "repeatMode", "static": "false", "kind": "field", "mainType": "PatternMode", "defaultValue": "PatternMode.Loop", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "graphicsList", "static": "false", "kind": "field", "mainType": "string[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "startOffset", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SolvePatternIndex", "static": "true", "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"index": {"paramType": "int", "defaultValue": ""}, "listLength": {"paramType": "int", "defaultValue": ""}, "mode": {"paramType": "PatternMode", "defaultValue": ""}}}], "comment": {"summary": " Applies graphics automatically to children in patterns. Of course nothing's stopping you from using only one graphic, if you just want to replace them. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetCollisionData": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [{"id": "newCollisionLayer", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "graze", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "power", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "health", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetMultimeshExtraData": {"kind": "class", "bases": ["Modifier"], "inners": {}, "declarations": [{"id": "color", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " We expect a Color here.  ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "custom", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " We expect a Vector4 here. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NewPointer", "static": "true", "kind": "method", "mainType": "BNodeMultimeshExtras*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Initialize", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"inStructure": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " Set color or custom data, as used in Multimesh fields. Useful to make bullets fade out or to pass special shader properties. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Shift": {"kind": "class", "bases": ["Modifier"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Set", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Completely replace the BNode's transform with ours. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ApplyAfter", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Add our transform after the existing one: as if our transform were a \"child\". ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ApplyBefore", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Add our transform before the existing one: as if our transform were a \"parent\". ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ChildPlacement": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Attached", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The default; children move along with this object as expected. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Static", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Children stay in their current place, even though their containing structure has been moved. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.ApplyAfter", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "childPlacement", "static": "false", "kind": "field", "mainType": "ChildPlacement", "defaultValue": "ChildPlacement.Attached", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rotation", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "offsetX", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "offsetY", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "scaleX", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "scaleY", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Move the transform of this BNode. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Shuffle": {"kind": "class", "bases": ["Modifier"], "inners": {"Mode": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Cut", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Remove the first n children and put them at the end. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Weave", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Divides the list into n parts and interleaves them in order. Excess will appear in a shortened group. Example: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] ---(n = 2)--&gt; [0, 6, 1, 7, 2, 8, 3, 9, 4, 10, 5, 11]<br /> Example: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] ---(n = 3)--&gt; [0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11]<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Leap", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Leaps over n items at a time to find the new order. If we leap past the end, loop back to the beginning. If we reach a child a second time, go forward by 1. Very useful for preparing star shapes.<br /> Example: [0, 1, 2, 3, 4] ---(n = 2)--&gt; [0, 2, 4, 1, 3]<br /> Example: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] ---(n = 2)--&gt; [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11]<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Reverse", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Puts children in backwards order. n doesn't matter. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Randomize", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " Randomizes the list order. n doesn't matter. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": "false", "kind": "field", "mainType": "Mode", "defaultValue": "Mode.Leap", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "n", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Rearrange the children of a structure in useful ways. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Circle": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "radius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"48\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CloneInPlace": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CurveScrimble": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "radius", "static": "false", "kind": "field", "mainType": "Curve", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angle", "static": "false", "kind": "field", "mainType": "Curve", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, interpolation is contracted so that a circle doesn't have a redundant first point. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radiusShift", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radiusLoopMode", "static": "false", "kind": "field", "mainType": "UnsafeCurve.LoopMode", "defaultValue": "UnsafeCurve.LoopMode.Neither", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angleShift", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angleLoopMode", "static": "false", "kind": "field", "mainType": "UnsafeCurve.LoopMode", "defaultValue": "UnsafeCurve.LoopMode.Neither", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " An extra-versatile shaper that can trace any parametric polar equation.<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PlaceRandom": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "minRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"48\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "maxRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"96\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "minAngle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "maxAngle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"90\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "correctForArea", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " If true, points at smaller radii will have a lower chance of being chosen, such that there is a uniform chance of bullets spawning throughout the area. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Makes clones appear in a random sector of a washer:  a region bounded by two lines through the center and two circles around the center. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Scrimble": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "startRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"48\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"96\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "startAngle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endAngle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"90\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If true, interpolation is contracted so that a circle doesn't have a redundant first point. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " A parametric \"line segment\", in polar coordinates. <br /> This versatile shaper can create rings, spreads, stacks, and more!<br /> (Of course the classic shapes still exist for convenience.) ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Spread": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "radius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"48\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angularWidth", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"180\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Also known as a fan. Places an arc of bullets. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Stack": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "startRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"48\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endRadius", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"96\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "angle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " A row of bullets with the same direction from the center, but different distance from the center. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Reflect": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "axisAngle", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"90\"", "comment": {"summary": " Angle the reflection axis makes with the transform's rightwards direction, in degrees. Clockwise by Godot convention. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Clone the BNode and reflect it across an axis. Useful for bilaterally symmetric patterns. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PlaceOnPath2D": {"kind": "class", "bases": ["Shaper"], "inners": {}, "declarations": [{"id": "path2D", "static": "false", "kind": "field", "mainType": "Path2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shrink", "static": "false", "kind": "field", "mainType": "float", "defaultValue": "10", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "extraRotation", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Place clones along a Path2D.  Local space in the path translates to local space of the inStructure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetVar": {"kind": "class", "bases": ["Discrete"], "inners": {"Environment": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Local", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Session", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Custom", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "varName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"temp\"", "comment": {"summary": " The variable's name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "environment", "static": "false", "kind": "field", "mainType": "Environment", "defaultValue": "Environment.Local", "comment": {"summary": " The scope where you are setting this variable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "newValue", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"sqrt(pow(3, 2) + pow(4, 2))\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customEnvironment", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "null", "comment": {"summary": " Used when environment is Custom. Sets virtual variable if it's a BaseVariableContainer, otherwise sets a Godot variable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Set a temporary variable to use in further calculations. This also works in schedulers, and can change an existing variable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UnsetVar": {"kind": "class", "bases": ["Discrete"], "inners": {}, "declarations": [{"id": "varName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"temp\"", "comment": {"summary": " The variable's name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "environment", "static": "false", "kind": "field", "mainType": "SetVar.Environment", "defaultValue": "SetVar.Environment.Local", "comment": {"summary": " The scope where you are setting this variable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customEnvironment", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "null", "comment": {"summary": " Used when environment is Custom. Sets virtual variable if it's a BaseVariableContainer, otherwise sets a Godot variable. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Remove a temporary variable. Not necessary, but gives you the peace of mind that memory won't be occupied by unused variables. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Connect": {"kind": "class", "bases": ["BaseOperation"], "inners": {"Structure": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Flat", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The result has the same depth.<br /> It is continuous in the order of connection. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SeparateLines", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The result is a deeper structure.<br /> Each line is a child of the result, and includes the start and end points.<br /> This means most or all of the original points are doubled up. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LineType": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Line", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The normal way of connecting the dots, with straight lines. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Scrimble", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": " The circular/polar way of connecting the dots, lerping radius and angle. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "structure", "static": "false", "kind": "field", "mainType": "Structure", "defaultValue": "Structure.Flat", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lineType", "static": "false", "kind": "field", "mainType": "LineType", "defaultValue": "LineType.Line", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "number", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"8\"", "comment": {"summary": " The number of bullets that fill out each line. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "circular", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": " If true, the last item will be connected to the first. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Connects the children of a structure with lines of same bullets. Literally \"connect the dots\"! Also interpolates rotation and scale.<br />", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Deepen": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "groupSize", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"12\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Puts the children into groups of a new structure such that they become the childrens' children.<br /> You can choose the size of the groups. Extraneous children that can't form a group are deleted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Flatten": {"kind": "class", "bases": ["BaseOperation"], "inners": {}, "declarations": [{"id": "keepEmptyChildren", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " Determines what to do with children that have zero children. False: Children with zero children are deleted, to keep remaining leaves on the same former level. True: Children with zero children are kept, to retain all former leaves. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "complete", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " If true, this will repeatedly flatten the structure until no child has children. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Puts the children into groups of a new structure such that they become the childrens' children.<br /> You can choose the size of the groups. Extraneous children that can't form a group are deleted. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Sound": {"kind": "class", "bases": ["Discrete"], "inners": {}, "declarations": [{"id": "soundObject", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "commonSFXName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "pitch", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "volume", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Plays a sound effect by direct reference or a common name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Trail": {"kind": "class", "bases": ["BaseOperation"], "inners": {"Data": {"kind": "struct", "bases": [], "inners": {}, "declarations": [{"id": "initializedDefaultTransform", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "defaultTransform", "static": "false", "kind": "field", "mainType": "Transform2D", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "worldPosBuffer", "static": "false", "kind": "field", "mainType": "UnsafeArray&lt;Transform2D&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "filled", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "currentUnscaledFrame", "static": "false", "kind": "field", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "number", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"8\"", "comment": {"summary": " The amount of bullets in the trail. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "frameDelay", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"2\"", "comment": {"summary": " The number of frames between each bullet in the trail. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "laserRenderName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"None\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "true", "kind": "method", "mainType": "BehaviorReceipt", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"nodeIndex": {"paramType": "int", "defaultValue": ""}, "stepSize": {"paramType": "float", "defaultValue": ""}, "dataPtr": {"paramType": "void*", "defaultValue": ""}}}, {"id": "CloneData", "static": "true", "kind": "method", "mainType": "void*", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dataPtr": {"paramType": "void*", "defaultValue": ""}}}, {"id": "DisposeData", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"dataPtr": {"paramType": "void*", "defaultValue": ""}}}, {"id": "CreateOrder", "static": "false", "kind": "method", "mainType": "BehaviorOrder", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"frameDelay": {"paramType": "int", "defaultValue": ""}, "startFrame": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": " Add a trail of bullets that mimic the head bullet exactly. Also creates lasers. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Sounds": {"classes": {"Music": {"kind": "class", "bases": ["AudioStreamPlayer"], "inners": {}, "declarations": [{"id": "main", "static": "true", "kind": "property", "mainType": "Music", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CommonSFXManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "sfxBusName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"SFX\"", "comment": {"summary": " If this string is non-empty, the audio bus of each effect will use it. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "property", "mainType": "CommonSFXManager", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Play", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"n": {"paramType": "Node", "defaultValue": ""}, "pitch": {"paramType": "float", "defaultValue": "1f"}, "volume": {"paramType": "float", "defaultValue": "1f"}, "position": {"paramType": "Vector2", "defaultValue": "default"}, "move": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "PlayByName", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}, "pitch": {"paramType": "float", "defaultValue": "1f"}, "volume": {"paramType": "float", "defaultValue": "1f"}, "position": {"paramType": "Vector2", "defaultValue": "default"}, "move": {"paramType": "bool", "defaultValue": "false"}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Input": {"classes": {"InputManager": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "buttonsHolder", "static": "false", "kind": "field", "mainType": "Node", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Reconfigure", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newButtonsHolder": {"paramType": "Node", "defaultValue": ""}}}, {"id": "GetRawCurrentState", "static": "true", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetRawStartedState", "static": "true", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetRawEndedState", "static": "true", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ButtonPressedThisFrame", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "ButtonPressedThisFrame", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "string", "defaultValue": ""}}}, {"id": "ButtonReleasedThisFrame", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "ButtonReleasedThisFrame", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "string", "defaultValue": ""}}}, {"id": "ButtonIsDown", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "ButtonIsDown", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "string", "defaultValue": ""}}}, {"id": "ButtonIsHeldLongEnough", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " Warning: this is always false when testing multiple buttons. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "ulong", "defaultValue": ""}, "frames": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "ButtonIsHeldLongEnough", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": " Warning: this is always 0 when testing multiple buttons. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "string", "defaultValue": ""}, "frames": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "GetButtonHeldFrames", "static": "true", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Warning: this is always 0 when testing multiple buttons. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "GetButtonHeldFrames", "static": "true", "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Warning: this is always 0 when testing multiple buttons. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"comp": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " Handles input for us in a centralized way. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ButtonInfo": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "defaultKey", "static": "false", "kind": "field", "mainType": "Key", "defaultValue": "Key.None", "comment": {"summary": " Default key that triggers this button when other inputs aren't configured or aren't available. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Debug": {"classes": {"GameFlow": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "frozen", "static": "true", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "commandGroup", "static": "true", "kind": "field", "mainType": "DebugConsole.CommandGroup", "defaultValue": "new DebugConsole.CommandGroup\r\n        {\r\n            groupName = \"Game Flow\",\r\n            commands = new System.Collections.Generic.List&lt;DebugConsole.Command&gt;()\r\n            {\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"speed\",\r\n                    usageTip = \"speed {new time scale}\",\r\n                    description = \"Changes the time scale of the game (once it's unpaused).\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        float newTimeScale = 1;\r\n                        if (args.Count &gt;= 2)\r\n                        {\r\n                            if (!float.TryParse(args[1], out newTimeScale))\r\n                            {\r\n                                DebugConsole.main.Print(\"No action: time scale must be a number within [lb]0.1, 10[rb].\");\r\n                                return;\r\n                            }\r\n                        }\r\n                        if (newTimeScale != Mathf.Clamp(newTimeScale, 0.1f, 10f))\r\n                        {\r\n                            DebugConsole.main.Print(\"No action: time scale must be a number within [lb]0.1, 10[rb].\");\r\n                            return;\r\n                        }\r\n                        Session.main.SetTimeScale(newTimeScale);\r\n                        DebugConsole.main.Print($\"Time scale is now {newTimeScale}\");\r\n                    }\r\n                },\r\n\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"freeze\",\r\n                    usageTip = \"freeze {on/off}\",\r\n                    description = \"When the game is frozen, all bullet behavior, firing, enemy movement, and stage progression will be stopped. \" +\r\n                                  \"Player actions aren't stopped.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        frozen = !frozen;\r\n                        if (args.Count &gt;= 2) { DebugConsole.SetTruthValue(args[1], ref frozen); }\r\n                        DebugConsole.main.Print($\"The game is now {(frozen ? \"frozen\" : \"unfrozen\")}.\");\r\n                    }\r\n                },\r\n\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"difficulty\",\r\n                    usageTip = \"difficulty {number}\",\r\n                    description = \"Sets game difficulty by its internally identifying number.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        if (args.Count &gt;= 2 && int.TryParse(args[1], out int newDif))\r\n                        {\r\n                            Session.main.SetDifficulty(newDif);\r\n                            DebugConsole.main.Print($\"Difficulty set to {Session.main.difficulty}\");\r\n                        }\r\n                        else\r\n                        {\r\n                            DebugConsole.main.Print(\"Difficulty not changed: invalid input.\");\r\n                        }\r\n                    }\r\n                },\r\n\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"rank\",\r\n                    usageTip = \"rank {number} {freeze: on/off}\",\r\n                    description = \"Sets game rank to number. You can also freeze rank at the number, using the second parameter.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        if (args.Count &gt;= 2 && float.TryParse(args[1], out float newRank))\r\n                        {\r\n                            Session.main.SetRank(newRank, true);\r\n                            bool frozen = false;\r\n                            if (args.Count &gt;= 3) { DebugConsole.SetTruthValue(args[2], ref frozen); }\r\n                            Session.main.rankFrozen = frozen;\r\n                            DebugConsole.main.Print($\"Rank set to {Session.main.rank}; {(frozen ? \"frozen\" : \"unfrozen\")}\");\r\n                        }\r\n                        else\r\n                        {\r\n                            DebugConsole.main.Print(\"Rank not changed: invalid input.\");\r\n                        }\r\n                    }\r\n                },\r\n            }\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DebugConsole": {"kind": "class", "bases": ["Control"], "inners": {"CommandGroup": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "groupName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "commands", "static": "false", "kind": "field", "mainType": "List&lt;Command&gt;", "defaultValue": "new List&lt;Command&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "MatchName", "static": "false", "kind": "method", "mainType": "Command", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"commandName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Command": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "name", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "aliases", "static": "false", "kind": "field", "mainType": "List&lt;string&gt;", "defaultValue": "new List&lt;string&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "usageTip", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "description", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "action", "static": "false", "kind": "field", "mainType": "Action&lt;List&lt;string&gt;&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "AliasesToString", "static": "false", "kind": "method", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "paused", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "inputLine", "static": "false", "kind": "field", "mainType": "LineEdit", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "lastText", "static": "false", "kind": "field", "mainType": "RichTextLabel", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "field", "mainType": "DebugConsole", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetTruthValue", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "string", "defaultValue": ""}, "set": {"paramType": "bool", "defaultValue": ""}}}, {"id": "Tokenize", "static": "true", "kind": "method", "mainType": "List&lt;string&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "string", "defaultValue": ""}}}, {"id": "Print", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "string", "defaultValue": ""}}}, {"id": "CloseExternal", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetCommandFromName", "static": "false", "kind": "method", "mainType": "Command", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"name": {"paramType": "string", "defaultValue": ""}}}, {"id": "ExecuteCommand", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"command": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "DebugCollision": {"kind": "class", "bases": ["Node2D"], "inners": {}, "declarations": [{"id": "showCollisionShapes", "static": "true", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "collisionShapesColor", "static": "true", "kind": "field", "mainType": "Color", "defaultValue": "Colors.Green", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "commandGroup", "static": "true", "kind": "field", "mainType": "DebugConsole.CommandGroup", "defaultValue": "new DebugConsole.CommandGroup\r\n        {\r\n            groupName = \"Collision\",\r\n            commands = new System.Collections.Generic.List&lt;DebugConsole.Command&gt;()\r\n            {\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"col_shapes\",\r\n                    usageTip = \"col_shapes {on/off} {color}\",\r\n                    description = \"Shows the collision shapes of all active colliders handled by Blastula, including bullets and lasers. \" +\r\n                                  \"This will likely severely hurt performance.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        showCollisionShapes = !showCollisionShapes;\r\n                        if (args.Count &gt;= 2) { DebugConsole.SetTruthValue(args[1], ref showCollisionShapes); }\r\n                        if (args.Count &gt;= 3) { collisionShapesColor = new Color(args[2]); }\r\n                        DebugConsole.main.Print(\r\n                            $\"Collision shapes are now {(showCollisionShapes ? \"visible\" : \"invisible\")} with color {collisionShapesColor.ToHtml()}\"\r\n                        );\r\n                    }\r\n                },\r\n\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"god\",\r\n                    usageTip = \"god {on/off} {left/right}\",\r\n                    description = \"Makes a player invulnerable to enemy and enemy bullet collisions. With left/right argument, \" +\r\n                                  \"you can choose which player in a two-player game.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        bool god = true;\r\n                        Player.Control control = Player.Control.SinglePlayer;\r\n                        if (args.Count &gt;= 2) { DebugConsole.SetTruthValue(args[1], ref god); }\r\n                        string l2 = \"\";\r\n                        if (args.Count &gt;= 3)\r\n                        {\r\n                            l2 = args[2].ToLower();\r\n                            if (l2 == \"left\" || l2 == \"l\") { control = Player.Control.LeftPlayer; }\r\n                            else if (l2 == \"right\" || l2 == \"r\") { control = Player.Control.RightPlayer; }\r\n                            else { l2 = \"\"; }\r\n                        }\r\n                        Player player = Player.playersByControl.ContainsKey(control) ? Player.playersByControl[control] : null;\r\n                        if (player == null)\r\n                        {\r\n                            DebugConsole.main.Print(\"No such player.\");\r\n                            return;\r\n                        }\r\n                        player.debugInvincible = god;\r\n                        string l2f = (l2 != \"\") ? \"(\" + l2 + \") \" : \"\";\r\n                        DebugConsole.main.Print($\"Player {l2f}is now {(god ? \"invulnerable\" : \"vulnerable\")}.\");\r\n                    }\r\n                },\r\n            }\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "DrawCollisionShape", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"canvas": {"paramType": "CanvasItem", "defaultValue": ""}, "bNodeIndex": {"paramType": "int", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StatsViews": {"kind": "class", "bases": ["Control"], "inners": {"Timings": {"kind": "class", "bases": [], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "currentMode", "static": "true", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "field", "mainType": "StatsViews", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "commandGroup", "static": "true", "kind": "field", "mainType": "DebugConsole.CommandGroup", "defaultValue": "new DebugConsole.CommandGroup\r\n        {\r\n            groupName = \"Stats Views\",\r\n            commands = new System.Collections.Generic.List&lt;DebugConsole.Command&gt;()\r\n            {\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"sv_off\",\r\n                    usageTip = \"sv_off\",\r\n                    description = \"Removes any open stats view.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        if (currentView != null) { currentView.Visible = false; }\r\n                        currentView = null;\r\n                        currentMode = \"\";\r\n                        DebugConsole.main.Print(\"Stats views have been closed.\");\r\n                    }\r\n                },\r\n\r\n                new DebugConsole.Command\r\n                {\r\n                    name = \"sv_timings\",\r\n                    usageTip = \"sv_timings\",\r\n                    description = \"Displays the time it takes to process essential functions of the engine.\",\r\n                    action = (args) =&gt;\r\n                    {\r\n                        if (currentView != null) { currentView.Visible = false; }\r\n                        currentView = main.FindChild(\"Timings\") as Control;\r\n                        currentView.Visible = true;\r\n                        currentMode = \"timings\";\r\n                        DebugConsole.main.Print(\"Timings are now visible.\");\r\n                    }\r\n                },\r\n            }\r\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Schedules.EnemySchedules": {"classes": {"SetInterpolationData": {"kind": "class", "bases": ["EnemySchedule"], "inners": {}, "declarations": [{"id": "moverID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"A\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "easingTransition", "static": "false", "kind": "field", "mainType": "Tween.TransitionType", "defaultValue": "Tween.TransitionType.Quad", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "easingType", "static": "false", "kind": "field", "mainType": "Tween.EaseType", "defaultValue": "Tween.EaseType.InOut", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tweenDuration", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0.5\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radialVelocityInterpolation", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Set interpolation data for an EnemyMover to change the style. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TriggerSpawner": {"kind": "class", "bases": ["EnemySchedule"], "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetTargetPosition": {"kind": "class", "bases": ["EnemySchedule"], "inners": {}, "declarations": [{"id": "moverID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"A\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "X", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Y", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"100\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Set the position of an enemy. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetTargetVelocity": {"kind": "class", "bases": ["EnemySchedule"], "inners": {}, "declarations": [{"id": "moverID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"A\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "radialMode", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " If radial mode is on: X is the speed, and Y is the angle of travel in degrees. If radial mode is off: X and Y are the speeds along their axes. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "X", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Y", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"100\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Set the target velocity of an enemy. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "EnemySchedule": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [], "comment": {"summary": " Schedule used for enemy or spawner logic. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Schedules": {"classes": {"BaseSchedule": {"kind": "class", "bases": ["Node"], "inners": {}, "declarations": [{"id": "referenceID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " Optional ID. If nonempty, this schedule can be referenced throughout all scenes, as long as it exists. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "referencesByID", "static": "true", "kind": "field", "mainType": "Dictionary&lt;string, BaseSchedule&gt;", "defaultValue": "new Dictionary&lt;string, BaseSchedule&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Execute", "static": "false", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"source": {"paramType": "IVariableContainer", "defaultValue": ""}}}, {"id": "Solve", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ScheduleReference": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "scheduleID", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "other", "static": "false", "kind": "field", "mainType": "BaseSchedule", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "waitForIDExistence", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Select": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "selection", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Selects a particular schedule at a child index. \"selection\" can be a true/false value or an integer. When it is true/false, evaluating to false will choose the first child (index 0). Evaluating to true chooses the second child (index 1). When it is an integer, it will choose the child at that index. Negative integers work as they do in Python, counting from the list's end. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SetContainerPosition": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "X", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Y", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "useGlobalPosition", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "setPositionVariable", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Directly sets the container's position. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Split": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [], "comment": {"summary": " Run all child schedules and shots at the same time. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Wait": {"kind": "class", "bases": ["BaseSchedule"], "inners": {"TimeUnits": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "Seconds", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Frames", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "waitTime", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "units", "static": "false", "kind": "field", "mainType": "TimeUnits", "defaultValue": "TimeUnits.Seconds", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Waits an amount of time. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "WaitUntil": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "condition", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"true\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Waits until the expression evaluates to something true. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StageSchedule": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "Execute", "static": "false", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " A schedule item used for stages. Ensures that no local container is involved. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CycleWhile": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "cycleCondition", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"t &lt; 5\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "completedCyclesVariableName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " This would the variable name of the current cycle we are on, starting at 0. When nonempty, it populates that temporary variable, to use in operations. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Executes child sequences and schedules in their tree order. Loops until the condition expression becomes false. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Cycle": {"kind": "class", "bases": ["BaseSchedule"], "inners": {}, "declarations": [{"id": "cycleCount", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " Solves this expression at the beginning of execution to determine how many times to loop. Empty string means it loops forever. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "completedCyclesVariableName", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " This would the variable name of the current cycle we are on, starting at 0. When nonempty, it populates that temporary variable, to use in operations. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Executes child sequences and schedules in their tree order. Loops a number of times you can specify. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "StageSector": {"kind": "class", "bases": ["StageSchedule"], "inners": {"State": {"kind": "enum", "bases": [], "inners": {}, "declarations": [{"id": "NotStarted", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Ongoing", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Complete", "static": "false", "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "duration", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " This portion of the stage will end after this number of seconds, if it's not yet ended. Leave blank to have infinite time. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "endWhenChildrenComplete", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " If true, end when all child schedules have been completed. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "shouldUseTimer", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "formation", "static": "false", "kind": "field", "mainType": "PackedScene", "defaultValue": "null", "comment": {"summary": " A scene which is loaded when this sector becomes executed. This could be a wave of enemies, but it could also be completely different. For example, we could load the overlay that introduces the stage. We could also load a boss, whose attacks are then loaded in child sectors. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "formationDeletionDelay", "static": "false", "kind": "field", "mainType": "string", "defaultValue": "\"0\"", "comment": {"summary": " The spawned formation instance is deleted after this number of seconds. Leave blank to have infinite time, but be advised that the Node will not be deleted automatically, which may cause the game's memory to be slowly burdened. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "state", "static": "false", "kind": "property", "mainType": "State", "defaultValue": "State.NotStarted", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetCurrentSector", "static": "true", "kind": "method", "mainType": "StageSector", "defaultValue": "", "comment": {"summary": " Get the sector at the top of the stack; the most granular one right now. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetCurrentEnemyFormation", "static": "true", "kind": "method", "mainType": "EnemyFormation", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetTimeRemaining", "static": "true", "kind": "method", "mainType": "double", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ShouldBeExecuting", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RunTime", "static": "false", "kind": "method", "mainType": "Task", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "EndCurrentSectorImmediately", "static": "true", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "EndImmediately", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Preload", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " Defines a portion of a stage, or the stage itself. It is meant to recursively contain smaller sections of the stage. It can also be used to simply load a scene. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.VirtualVariables": {"classes": {"IVariableContainer": {"kind": "interface", "bases": [], "inners": {}, "declarations": [{"id": "customData", "static": "false", "kind": "property", "mainType": "Dictionary&lt;string, Variant&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Reset", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "GetVar", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}, {"id": "SetVar", "static": "false", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}, "newData": {"paramType": "Variant", "defaultValue": ""}}}, {"id": "ClearAllVars", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ClearVar", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Persistent": {"kind": "class", "bases": ["Node", "IVariableContainer"], "inners": {"Priorities": {"kind": "class", "bases": [], "inners": {}, "declarations": [{"id": "FRAME_COUNTER_INCREMENT", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "int.MinValue", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "EXECUTE", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "40000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "COLLISION", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "50000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "POST_EXECUTE", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "60000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RENDER", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "70000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "RENDER_DEBUG_COLLISIONS", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "70001", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PAUSE", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "100000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "CONSUME_INPUT", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "int.MaxValue", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "BLASTULA_ROOT_PATH", "static": "true", "kind": "const", "mainType": "string", "defaultValue": "\"res://addons/Blastula\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NODE_ICON_PATH", "static": "true", "kind": "const", "mainType": "string", "defaultValue": "BLASTULA_ROOT_PATH + \"/Graphics/NodeIcons\"", "comment": {"summary": " Used for the editor to find custom icons. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SIMULATED_FPS", "static": "true", "kind": "const", "mainType": "int", "defaultValue": "60", "comment": {"summary": " This determines the timestep of behaviors. The actual framerate may be lower. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "LAZY_SAFE_DISTANCE", "static": "true", "kind": "const", "mainType": "float", "defaultValue": "140", "comment": {"summary": " This is the space between a collision object and a bullet, such that a lazy bullet feels safe to sleep for a few frames before checking collision again. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "main", "static": "true", "kind": "property", "mainType": "Persistent", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customData", "static": "false", "kind": "property", "mainType": "Dictionary&lt;string, Variant&gt;", "defaultValue": "new Dictionary&lt;string, Variant&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "new HashSet&lt;string&gt;()\n        {\n            \"fps\", \"simulated_fps\"\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " These variables are meant to persist as long as the program is running. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Session": {"kind": "class", "bases": ["Node", "IVariableContainer"], "inners": {}, "declarations": [{"id": "canPause", "static": "false", "kind": "property", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " True if the game can be paused. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "paused", "static": "false", "kind": "property", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " True if the game is paused. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "timeScale", "static": "false", "kind": "property", "mainType": "double", "defaultValue": "1.0", "comment": {"summary": " The time scale used for bullet behavior. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "difficulty", "static": "false", "kind": "property", "mainType": "int", "defaultValue": "1", "comment": {"summary": " This integer is the game's difficulty, if you choose to use it. Standard convention is 0: easy, 1: normal, 2: hard, 3: (whatever funny name you give to the hardest difficulty) But anything's possible! ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rank", "static": "false", "kind": "property", "mainType": "float", "defaultValue": "0.5f", "comment": {"summary": " This is the game's rank, if you choose to use it. Rank is a common element in classic STGs, similar to a sub-difficulty, and usually adapts to how well the player progresses by changing bullet pattern density or speed. I suggest varying it within the interval [0, 1]. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "rankFrozen", "static": "false", "kind": "field", "mainType": "bool", "defaultValue": "false", "comment": {"summary": " True if we don't want the rank to change. Good for testing and practicing. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetCanPause", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"s": {"paramType": "bool", "defaultValue": ""}}}, {"id": "Pause", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Unpause", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetTimeScale", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newTimeScale": {"paramType": "double", "defaultValue": ""}}}, {"id": "Reset", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "IsPaused", "static": "true", "kind": "method", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SetDifficulty", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"newDifficulty": {"paramType": "int", "defaultValue": ""}}}, {"id": "SetRank", "static": "false", "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {"newRank": "Rank value to replace the old one.", "force": "If true, change the rank even while it's frozen."}, "typeParams": {}}, "methodParams": {"newRank": {"paramType": "float", "defaultValue": ""}, "force": {"paramType": "bool", "defaultValue": "false"}}}, {"id": "main", "static": "true", "kind": "property", "mainType": "Session", "defaultValue": "null", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "customData", "static": "false", "kind": "property", "mainType": "Dictionary&lt;string, Variant&gt;", "defaultValue": "new Dictionary&lt;string, Variant&gt;()", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "specialNames", "static": "false", "kind": "property", "mainType": "HashSet&lt;string&gt;", "defaultValue": "new HashSet&lt;string&gt;()\n        {\n            \"can_pause\", \"paused\", \"time_scale\", \"difficulty\", \"dif\", \"rank\"\n        }", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetSpecial", "static": "false", "kind": "method", "mainType": "Variant", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"varName": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " These variables are meant to persist within game sessions (between going back to the start menu). ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}}}