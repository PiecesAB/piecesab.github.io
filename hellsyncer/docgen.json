{"date": "3/22/2024 6:09:11 AM", "namespaces": {"HellSyncer": {"classes": {"AudioStreamSynced": {"kind": "class", "bases": ["AudioStreamPlayer"], "abstract": false, "inners": {}, "declarations": [{"id": "mainLoop", "static": false, "kind": "field", "mainType": "Vector2", "defaultValue": "Vector2.Zero", "comment": {"summary": " If this isn't the zero vector, (X, Y) represents the (start, end) of the looping region of this music track. So once the music passes the loop end, it will seek (Y - X) seconds backward. MIDI events are looped appropriately to match. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "midi", "static": false, "kind": "field", "mainType": "ParsedMidi", "defaultValue": "", "comment": {"summary": " The MIDI file which this audio player is tied to.  If null, generatedBpm and generatedTimeSignature will be used to create a simple MIDI file for the beat. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "generatedBpm", "static": false, "kind": "field", "mainType": "float", "defaultValue": "120f", "comment": {"summary": " Used when midi == null. Quarter notes per minute. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "generatedTimeSignature", "static": false, "kind": "field", "mainType": "Vector2I", "defaultValue": "new Vector2I(4, 4)", "comment": {"summary": " Used when midi == null. (X, Y) is (numerator, denominator) of the time signature. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "TOLERANCE", "static": true, "kind": "const", "mainType": "float", "defaultValue": "0.03f", "comment": {"summary": " If the audible music gets this far from the MIDI (in seconds), then we will force the music to lag or skip. The reason this happens is because of unpredictable lag in the game, but the MIDI needs to run deterministically (for replays). It's not pretty, but it keeps the sync. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PROCESS_PRIORITY", "static": true, "kind": "const", "mainType": "int", "defaultValue": "-1000000", "comment": {"summary": " Occurs early in the frame to allow other items to respond to the changes ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnNote", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"info": {"paramType": "FullNoteInfo", "defaultValue": ""}}}, {"id": "OnText", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "BaseTextEvent", "defaultValue": ""}}}, {"id": "main", "static": true, "kind": "field", "mainType": "AudioStreamSynced", "defaultValue": "", "comment": {"summary": " There can currently be only one AudioStreamSynced at a time. This is the one. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "TickToTime", "static": false, "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": " Converts MIDI tick count to track time in seconds. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"tick": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "TimeToTick", "static": false, "kind": "method", "mainType": "ulong", "defaultValue": "", "comment": {"summary": " Converts track time in seconds to MIDI tick count. ", "examples": [], "remarks": " Important to seek somewhere in a MIDI using only a number of seconds. ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"time": {"paramType": "float", "defaultValue": ""}}}, {"id": "AddInstrumentListener", "static": true, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ins": {"paramType": "Instrument", "defaultValue": ""}}}, {"id": "RemoveInstrumentListener", "static": true, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"ins": {"paramType": "Instrument", "defaultValue": ""}}}, {"id": "AddTextListener", "static": true, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"con": {"paramType": "MidiTextReader", "defaultValue": ""}}}, {"id": "RemoveTextListener", "static": true, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"con": {"paramType": "MidiTextReader", "defaultValue": ""}}}, {"id": "GetBeatAndMeasure", "static": false, "kind": "method", "mainType": "(ulong measure, float beat)", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetTempo", "static": false, "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "Quarter notes per minute.", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PlaySynced", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Start from the beginning and play the audio in sync with the MIDI. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " An AudioStreamPlayer that follows a MIDI, which plays deterministically. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Persistent": {"kind": "class", "bases": [], "abstract": false, "inners": {}, "declarations": [{"id": "HELLSYNCER_ROOT_PATH", "static": true, "kind": "const", "mainType": "string", "defaultValue": "\"res://addons/HellSyncer\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NODE_ICON_PATH", "static": true, "kind": "const", "mainType": "string", "defaultValue": "HELLSYNCER_ROOT_PATH + \"/Graphics/NodeIcons\"", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Instrument": {"kind": "class", "bases": ["Node"], "abstract": false, "inners": {}, "declarations": [{"id": "trackIds", "static": false, "kind": "field", "mainType": "int[]", "defaultValue": "new int[1] { 1 }", "comment": {"summary": " A whitelist to choose which MIDI tracks can use notes to trigger this instrument. ", "examples": [], "remarks": " To view the tracks of a MIDI file and get an idea of what each track number contains, you will need an external editor. Be aware that HellSyncer considers the first track \"Track 0\", because it's possible the external MIDI editor considers the first track \"Track 1\". ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "noteRanges", "static": false, "kind": "field", "mainType": "Vector2[]", "defaultValue": "new Vector2[1] { new Vector2(0, 127) }", "comment": {"summary": " A whitelist to restrict the range of notes which trigger this instrument. Each vector (X, Y) is an interval of MIDI tones X to Y, including X and Y. ", "examples": ["Middle C = C4 = MIDI tone 60", "One semitone above middle C = C#4 = MIDI tone 61", "Lowest A on the standard piano = A0 = MIDI tone 21"], "remarks": "MIDI tones are integers 0-127 that each correspond to one semitone.", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "minimumVelocity", "static": false, "kind": "field", "mainType": "int", "defaultValue": "0", "comment": {"summary": " The minimum velocity of note which triggers this instrument. In other words, the note must be at least this loud. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PROCESS_PRIORITY", "static": true, "kind": "const", "mainType": "int", "defaultValue": "AudioStreamSynced.PROCESS_PRIORITY + 1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnNoteEventHandler", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"midiTone": {"paramType": "int", "defaultValue": ""}, "velocity": {"paramType": "int", "defaultValue": ""}, "duration": {"paramType": "float", "defaultValue": ""}}}, {"id": "SelfOnNote", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"note": {"paramType": "FullNoteInfo", "defaultValue": ""}}}], "comment": {"summary": " Monitor to filter and emit signals when MIDI note events play. ", "examples": [], "remarks": " Naturally, AudioStreamSynced.main must exist and be currently playing for this to emit any signals. ", "returns": "", "params": {}, "typeParams": {}}}, "MidiTextReader": {"kind": "class", "bases": ["Node"], "abstract": false, "inners": {}, "declarations": [{"id": "textEventType", "static": false, "kind": "field", "mainType": "TextEventID", "defaultValue": "TextEventID.Any", "comment": {"summary": " Filter out any text event that doesn't match this type. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "magicPhrase", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " If not empty, filter out any text event that doesn't contain this substring. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PROCESS_PRIORITY", "static": true, "kind": "const", "mainType": "int", "defaultValue": "AudioStreamSynced.PROCESS_PRIORITY + 1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnTextEventHandler", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "string", "defaultValue": ""}}}, {"id": "SelfOnText", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"@event": {"paramType": "BaseTextEvent", "defaultValue": ""}}}], "comment": {"summary": " Emits a signal for text events embedded in the MIDI. ", "examples": [], "remarks": " Naturally, AudioStreamSynced.main must exist and be currently playing for this to emit any signals. ", "returns": "", "params": {}, "typeParams": {}}}, "Metronome": {"kind": "class", "bases": ["Node"], "abstract": false, "inners": {}, "declarations": [{"id": "intervalQuarterNotes", "static": false, "kind": "field", "mainType": "float", "defaultValue": "1f", "comment": {"summary": " The length of an interval, which is a number of quarter notes. ", "examples": ["0.25: an interval is one sixteenth note long.", "2: an interval is one half note long.", "1.5: an interval is one dotted quarter note long. (Note: a new interval begins every measure, so depending on time signature, the last measure's final interval may be cut short.)", "0.333: an interval is one triplet eighth note long."], "remarks": " If this is extremely small (think 64th notes), it's possible that an interval is shorter than one frame. When this happens, only one OnInterval signal is sent per frame, and the metronome will lag behind. So avoid extremely small intervals if you can. ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugMeasureSound", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " Sound ID to play when a measure begins. Useful for testing a rhythm. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "debugBeatSound", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " Sound ID to play when an interval begins. Useful for testing a rhythm. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PROCESS_PRIORITY", "static": true, "kind": "const", "mainType": "int", "defaultValue": "AudioStreamSynced.PROCESS_PRIORITY + 1", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnMeasureEventHandler", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"measureNumber": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "OnIntervalEventHandler", "static": false, "kind": "delegate", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"measureNumber": {"paramType": "ulong", "defaultValue": ""}, "beat": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": " Monitor to filter and emit signals based on the MIDI's rhythm. This emits two kinds of signals: one for when the measure begins, and one for when an \"interval\" in that measure begins, which has the duration of a customizable number of quarter notes. ", "examples": [], "remarks": " Naturally, AudioStreamSynced.main must exist and be currently playing for this to emit any signals. ", "returns": "", "params": {}, "typeParams": {}}}}}, "HellSyncer.Midi": {"classes": {"EventID": {"kind": "enum", "bases": [], "abstract": false, "inners": {}, "declarations": [{"id": "Unsupported", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0x0000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NoteOff", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0x8000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "NoteOn", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0x9000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "KeyPressure", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xA000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ControlChange", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xB000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ProgramChange", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xC000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ChannelPressure", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xD000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "PitchBend", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xE000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SysExF0", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xF000", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "SysExF7", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xF700", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Text", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF01", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Copyright", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF02", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "TrackName", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF03", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "InstrumentName", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF04", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Lyric", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF05", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Marker", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF06", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Cue", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF07", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "EndOfTrack", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF2F", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Tempo", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF51", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "TimeSignature", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF58", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "KeySignature", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF59", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TextEventID": {"kind": "enum", "bases": [], "abstract": false, "inners": {}, "declarations": [{"id": "Any", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF00", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Text", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF01", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Copyright", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF02", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "TrackName", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF03", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "InstrumentName", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF04", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Lyric", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF05", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Marker", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF06", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Cue", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "0xFF07", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ParsedMidi": {"kind": "class", "bases": ["Resource"], "abstract": false, "inners": {"SortFullNotesByStart": {"kind": "class", "bases": ["IComparer&lt;FullNoteInfo&gt;"], "abstract": false, "inners": {}, "declarations": [{"id": "Compare", "static": false, "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"x": {"paramType": "FullNoteInfo", "defaultValue": ""}, "y": {"paramType": "FullNoteInfo", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "tracks", "static": false, "kind": "field", "mainType": "Track[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ticksPerQN", "static": false, "kind": "field", "mainType": "ushort", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadByte", "static": false, "kind": "method", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadTwoBytes", "static": false, "kind": "method", "mainType": "(byte, byte)", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadNBytes", "static": false, "kind": "method", "mainType": "byte[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"n": {"paramType": "uint", "defaultValue": ""}}}, {"id": "ReadShort", "static": false, "kind": "method", "mainType": "ushort", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadInt", "static": false, "kind": "method", "mainType": "uint", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadIntVarLen", "static": false, "kind": "method", "mainType": "uint", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadString", "static": false, "kind": "method", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadHeader", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadTrackEvent", "static": false, "kind": "method", "mainType": "TrackEvent", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "ReadTrack", "static": false, "kind": "method", "mainType": "Track", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"skip": {"paramType": "bool", "defaultValue": ""}}}, {"id": "ParseRaw", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Creates a ParsedMidi from a .mid/.midi file. ", "examples": [], "remarks": "", "returns": "", "params": {"raw": "The file as a byte array.", "trackRanges": " Whitelist of track numbers to import. Each vector (X, Y) is a range of track numbers X to Y, including X and Y. Track 0 is always imported regardless of this list. "}, "typeParams": {}}, "methodParams": {"raw": {"paramType": "byte[]", "defaultValue": ""}, "trackRanges": {"paramType": "Vector2[]", "defaultValue": ""}}}, {"id": "GenerateForBeat", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Creates a simple ParsedMidi using a tempo and time signature. ", "examples": [], "remarks": "", "returns": "", "params": {"bpm": "Quarter notes per minute.", "timeSignature": "(X, Y) is the (numerator, denominator)."}, "typeParams": {}}, "methodParams": {"bpm": {"paramType": "float", "defaultValue": ""}, "timeSignature": {"paramType": "Vector2I", "defaultValue": ""}}}], "comment": {"summary": " Resource which contains Godot-friendly MIDI data. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "MidiImporter": {"kind": "class", "bases": ["EditorImportPlugin"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": " Editor plugin that can import .mid/.midi files. ", "examples": [], "remarks": " Be sure to check the Import menu!!! By default, to save on storage size, we only import the first track of the MIDI, which we number as \"Track 0\", and in Format 1 MIDIs, this contains only the tempo, time signature, and other orchestration information. Track 0 is always imported. To select more tracks to import, you must add vectors to Track Ranges in the Import menu. Each vector (X, Y) represents an interval of track numbers X to Y, including X and Y.<br /><br /> To view the tracks of a MIDI file and get an idea of what each track number contains, you will need an external editor. Be aware that HellSyncer considers the first track \"Track 0\", because it's possible the external MIDI editor considers the first track \"Track 1\". ", "returns": "", "params": {}, "typeParams": {}}}, "SysExF7Event": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "data", "static": false, "kind": "field", "mainType": "byte[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TrackEvent": {"kind": "class", "bases": ["Resource"], "abstract": false, "inners": {}, "declarations": [{"id": "displayID", "static": false, "kind": "field", "mainType": "EventID", "defaultValue": "EventID.Unsupported", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "tick", "static": false, "kind": "field", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TrackNameEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TextEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "SysExF0Event": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "data", "static": false, "kind": "field", "mainType": "byte[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "UnsupportedEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ProgramChangeEvent": {"kind": "class", "bases": ["ChannelEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "newProgramNumber", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "NoteOffEvent": {"kind": "class", "bases": ["PVEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "MarkerEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PitchBendEvent": {"kind": "class", "bases": ["ChannelEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "newValue", "static": false, "kind": "field", "mainType": "short", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "NoteOnEvent": {"kind": "class", "bases": ["PVEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "LyricEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "KeyPressureEvent": {"kind": "class", "bases": ["PVEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "KeySignatureEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "sharpCount", "static": false, "kind": "field", "mainType": "sbyte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "isMinor", "static": false, "kind": "field", "mainType": "bool", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "EndOfTrackEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CopyrightEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "CueEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ChannelPressureEvent": {"kind": "class", "bases": ["ChannelEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "pressure", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ChannelEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "channel", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "BaseTextEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "text", "static": false, "kind": "field", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "ControlChangeEvent": {"kind": "class", "bases": ["ChannelEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "controllerNumber", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "newValue", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "InstrumentNameEvent": {"kind": "class", "bases": ["BaseTextEvent"], "abstract": false, "inners": {}, "declarations": [], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TempoEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "microsecondsPerQN", "static": false, "kind": "field", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetBPM", "static": false, "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "TimeSignatureEvent": {"kind": "class", "bases": ["TrackEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "numerator", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "denominator", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetFractionString", "static": false, "kind": "method", "mainType": "string", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "PVEvent": {"kind": "class", "bases": ["ChannelEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "note", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "velocity", "static": false, "kind": "field", "mainType": "byte", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "Track": {"kind": "class", "bases": ["Resource"], "abstract": false, "inners": {}, "declarations": [{"id": "trackEvents", "static": false, "kind": "field", "mainType": "TrackEvent[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "fullNoteInfos", "static": false, "kind": "field", "mainType": "FullNoteInfo[]", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetFullNoteIndexAtTick", "static": false, "kind": "method", "mainType": "int", "defaultValue": "", "comment": {"summary": " Return the earliest event index that begins on or after the tick (has not yet occurred). If no such event exists, it will return trackEvents.Length (representing the end). ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"tick": {"paramType": "ulong", "defaultValue": ""}}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "FullNoteInfo": {"kind": "class", "bases": ["NoteOnEvent"], "abstract": false, "inners": {}, "declarations": [{"id": "durationInTicks", "static": false, "kind": "field", "mainType": "ulong", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "GetDuration", "static": false, "kind": "method", "mainType": "float", "defaultValue": "", "comment": {"summary": " Duration in seconds at current tempo ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": " A NoteOn MIDI event for which a NoteOff event has been corresponded. We can thus get the duration of the note and store it together as a \"full note\" here. ", "examples": [" Getting the duration of notes is important for certain barrage effects. It can be used, for instance, to shoot a piano roll of lasers, where laser length and note length exactly correspond. "], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}, "Blastula.Schedules": {"classes": {"WaitForInstrument": {"kind": "class", "bases": ["BaseSchedule"], "abstract": false, "inners": {}, "declarations": [{"id": "instrument", "static": false, "kind": "field", "mainType": "Instrument", "defaultValue": "", "comment": {"summary": " Respond to when this Instrument detects a note. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "buildup", "static": false, "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " If true, notes will build up while we're waiting elsewhere. This causes no wait to occur when new notes are available. ", "examples": [], "remarks": " Allows for proper polyphony when this is the only wait in the schedule loop. ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "toneVarName", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " The note's MIDI tone, which is an integer from 0-127, will be set locally in this variable name. Each integer corresponds to one semitone. ", "examples": ["Middle C = C4 = MIDI tone 60", "One semitone above middle C = C#4 = MIDI tone 61", "Lowest A on the standard piano = A0 = MIDI tone 21"], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "velocityVarName", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " The note's MIDI velocity, which is an integer from 0-127, will be set locally in this variable name. ", "examples": ["1 is as quiet as possible while still playing anything.", "127 is as loud as possible."], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "durationVarName", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " The duration of the note in seconds will be set locally in this variable name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnNote", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Recieves the signal from the Instrument. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"midiTone": {"paramType": "int", "defaultValue": ""}, "velocity": {"paramType": "int", "defaultValue": ""}, "duration": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": " Waits for a note to be played. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "WaitForMetronome": {"kind": "class", "bases": ["BaseSchedule"], "abstract": false, "inners": {"Mode": {"kind": "enum", "bases": [], "abstract": false, "inners": {}, "declarations": [{"id": "Intervals", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "Measures", "static": false, "kind": "enum-member", "mainType": "", "defaultValue": "", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}], "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}, "declarations": [{"id": "mode", "static": false, "kind": "field", "mainType": "Mode", "defaultValue": "Mode.Intervals", "comment": {"summary": "", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "metronome", "static": false, "kind": "field", "mainType": "Metronome", "defaultValue": "", "comment": {"summary": " Respond to when this metronome ticks an interval or measure. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "count", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"1\"", "comment": {"summary": " The number of intervals or measures to wait. This should be a positive integer. ", "examples": [], "remarks": " If you would like to wait a fraction of an interval, decrease the metronome's interval duration,  or use a new metronome with a smaller interval. ", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnMeasure", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Recieves the Metronome measure tick. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"measure": {"paramType": "ulong", "defaultValue": ""}}}, {"id": "OnInterval", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Recieves the Metronome interval tick. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"measure": {"paramType": "ulong", "defaultValue": ""}, "beat": {"paramType": "float", "defaultValue": ""}}}], "comment": {"summary": " Waits a number of metronome intervals or measures. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}, "WaitForMidiText": {"kind": "class", "bases": ["BaseSchedule"], "abstract": false, "inners": {}, "declarations": [{"id": "textReader", "static": false, "kind": "field", "mainType": "MidiTextReader", "defaultValue": "", "comment": {"summary": " Respond to when this MidiTextReader encounters a matching text event. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "buildup", "static": false, "kind": "field", "mainType": "bool", "defaultValue": "true", "comment": {"summary": " If true, text events will build up while we're waiting elsewhere. This causes no wait to occur when new events are available. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "textVarName", "static": false, "kind": "field", "mainType": "string", "defaultValue": "\"\"", "comment": {"summary": " If not empty, the text will be set locally in this variable name. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {}}, {"id": "OnText", "static": false, "kind": "method", "mainType": "void", "defaultValue": "", "comment": {"summary": " Recieves text signal from MidiTextReader. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}, "methodParams": {"text": {"paramType": "string", "defaultValue": ""}}}], "comment": {"summary": " Waits for a MIDI text event to occur, as notified by a MidiTextReader. ", "examples": [], "remarks": "", "returns": "", "params": {}, "typeParams": {}}}}}}}